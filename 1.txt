diff --git a/admin_panel.py b/admin_panel.py
index 0a7501fa2bf5e82287aa2ec742f194dff09c0a42..3ba29db6d581b89a3d445adc0d67c46b229827b8 100644
--- a/admin_panel.py
+++ b/admin_panel.py
@@ -1,203 +1,211 @@
 """Administrative tools for configuring the webinar bot."""
 from __future__ import annotations
 
 from datetime import datetime
 from pathlib import Path
 
 from telegram import ReplyKeyboardMarkup, ReplyKeyboardRemove, Update
 from telegram.constants import ParseMode
 from telegram.ext import (
     CommandHandler,
     ContextTypes,
     ConversationHandler,
     MessageHandler,
     filters,
 )
 
 import database
-from config import ADMIN_CHAT_ID, load_settings, update_settings
+from config import is_admin, load_settings, update_settings
 from scheduler import ensure_scheduler_started, schedule_all_reminders
 
 MENU_KEYBOARD = ReplyKeyboardMarkup(
     [
         ["📆 Изменить дату", "📝 Изменить тему"],
         ["🔗 Обновить Zoom", "💳 Обновить оплату"],
         ["📥 Список участников", "📢 Разослать напоминание"],
     ],
     resize_keyboard=True,
 )
 
 STATE_TOPIC, STATE_DATE, STATE_ZOOM, STATE_PAYMENT, STATE_NOTIFY = range(5)
 
 
 def _is_admin(update: Update) -> bool:
     user = update.effective_user
-    return bool(user and user.id == ADMIN_CHAT_ID)
+    return bool(user and is_admin(chat_id=user.id, username=user.username))
+
+
+async def _ensure_admin(update: Update, *, message: str = "Недостаточно прав.") -> bool:
+    if _is_admin(update):
+        return True
+    if update.message:
+        await update.message.reply_text(message)
+    else:
+        await update.effective_chat.send_message(message)
+    return False
 
 
 async def send_admin_panel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
     settings = load_settings()
     text = (
         "<b>Панель администратора</b>\n\n"
         f"Тема: {settings.get('topic')}\n"
         f"Описание: {settings.get('description')}\n"
         f"Дата: {settings.get('event_datetime') or 'не задана'}\n"
         f"Zoom: {settings.get('zoom_link') or 'не задан'}\n"
         f"Оплата: {settings.get('payment_link') or 'не задана'}"
     )
     if update.message:
         await update.message.reply_text(text, parse_mode=ParseMode.HTML, reply_markup=MENU_KEYBOARD)
     else:
         await update.effective_chat.send_message(text, parse_mode=ParseMode.HTML, reply_markup=MENU_KEYBOARD)
 
 
 async def admin_command_entry(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-    if not _is_admin(update):
-        await update.message.reply_text("Эта команда доступна только администратору.")
+    if not await _ensure_admin(update, message="Эта команда доступна только администратору."):
         return ConversationHandler.END
     await send_admin_panel(update, context)
     return ConversationHandler.END
 
 
 async def set_topic_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-    if not _is_admin(update):
+    if not await _ensure_admin(update):
         return ConversationHandler.END
     await update.message.reply_text(
         "Введите новую тему и описание через символ \"|\".\n"
         "Например: Мой вебинар | Погружение в психологию",
         reply_markup=ReplyKeyboardRemove(),
     )
     return STATE_TOPIC
 
 
 async def set_topic_finish(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-    if not _is_admin(update):
+    if not await _ensure_admin(update):
         return ConversationHandler.END
     payload = (update.message.text or "").split("|", maxsplit=1)
     topic = payload[0].strip() if payload else ""
     description = payload[1].strip() if len(payload) > 1 else ""
     update_settings(topic=topic or None, description=description or None)
     await update.message.reply_text("Тема и описание обновлены.", reply_markup=MENU_KEYBOARD)
     return ConversationHandler.END
 
 
 def _parse_datetime(text: str) -> datetime:
     text = text.strip()
     formats = ["%d.%m.%Y %H:%M", "%d.%m %H:%M"]
     for fmt in formats:
         try:
             dt = datetime.strptime(text, fmt)
             if fmt == "%d.%m %H:%M":
                 dt = dt.replace(year=datetime.now().year)
             return dt
         except ValueError:
             continue
     raise ValueError("invalid format")
 
 
 async def set_date_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-    if not _is_admin(update):
+    if not await _ensure_admin(update):
         return ConversationHandler.END
     await update.message.reply_text(
         "Введите дату и время в формате ДД.ММ.ГГГГ ЧЧ:ММ или ДД.ММ ЧЧ:ММ",
         reply_markup=ReplyKeyboardRemove(),
     )
     return STATE_DATE
 
 
 async def set_date_finish(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-    if not _is_admin(update):
+    if not await _ensure_admin(update):
         return ConversationHandler.END
     text = update.message.text or ""
     try:
         event_dt = _parse_datetime(text)
     except ValueError:
         await update.message.reply_text("Не удалось распознать дату. Попробуйте снова.")
         return STATE_DATE
 
     update_settings(event_datetime=event_dt.isoformat())
     await update.message.reply_text("Дата вебинара обновлена.", reply_markup=MENU_KEYBOARD)
     ensure_scheduler_started()
     schedule_all_reminders(context.application)
     return ConversationHandler.END
 
 
 async def set_zoom_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-    if not _is_admin(update):
+    if not await _ensure_admin(update):
         return ConversationHandler.END
     await update.message.reply_text("Отправьте новую Zoom-ссылку:", reply_markup=ReplyKeyboardRemove())
     return STATE_ZOOM
 
 
 async def set_zoom_finish(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-    if not _is_admin(update):
+    if not await _ensure_admin(update):
         return ConversationHandler.END
     link = (update.message.text or "").strip()
     update_settings(zoom_link=link)
     await update.message.reply_text("Ссылка Zoom обновлена.", reply_markup=MENU_KEYBOARD)
     schedule_all_reminders(context.application)
     return ConversationHandler.END
 
 
 async def set_payment_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-    if not _is_admin(update):
+    if not await _ensure_admin(update):
         return ConversationHandler.END
     await update.message.reply_text("Отправьте ссылку на оплату (Robokassa):", reply_markup=ReplyKeyboardRemove())
     return STATE_PAYMENT
 
 
 async def set_payment_finish(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-    if not _is_admin(update):
+    if not await _ensure_admin(update):
         return ConversationHandler.END
     link = (update.message.text or "").strip()
     update_settings(payment_link=link)
     await update.message.reply_text("Ссылка на оплату обновлена.", reply_markup=MENU_KEYBOARD)
     return ConversationHandler.END
 
 
 async def export_participants(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-    if not _is_admin(update):
-        await update.message.reply_text("Недостаточно прав.")
+    if not await _ensure_admin(update):
         return ConversationHandler.END
     path = database.export_database()
     await update.message.reply_document(document=path.read_bytes(), filename=Path(path).name)
     return ConversationHandler.END
 
 
 async def notify_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-    if not _is_admin(update):
+    if not await _ensure_admin(update):
         return ConversationHandler.END
     await update.message.reply_text(
         "Введите текст напоминания, который будет отправлен всем участникам:",
         reply_markup=ReplyKeyboardRemove(),
     )
     return STATE_NOTIFY
 
 
 async def notify_finish(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-    if not _is_admin(update):
+    if not await _ensure_admin(update):
         return ConversationHandler.END
     text = update.message.text or ""
     participants = database.list_chat_ids()
     for chat_id in participants:
         await context.bot.send_message(chat_id=chat_id, text=text)
     await update.message.reply_text("Рассылка отправлена.", reply_markup=MENU_KEYBOARD)
     return ConversationHandler.END
 
 
 def build_admin_conversation() -> ConversationHandler:
     return ConversationHandler(
         entry_points=[
             CommandHandler("admin", admin_command_entry),
             CommandHandler("set_topic", set_topic_start),
             CommandHandler("set_date", set_date_start),
             CommandHandler("set_zoom", set_zoom_start),
             CommandHandler("set_payment", set_payment_start),
             CommandHandler("export", export_participants),
             CommandHandler("notify", notify_start),
             MessageHandler(filters.Regex("^📝"), set_topic_start),
             MessageHandler(filters.Regex("^📆"), set_date_start),
             MessageHandler(filters.Regex("^🔗"), set_zoom_start),
             MessageHandler(filters.Regex("^💳"), set_payment_start),
             MessageHandler(filters.Regex("^📥"), export_participants),
             MessageHandler(filters.Regex("^📢"), notify_start),
diff --git a/config.py b/config.py
index 87c499c9a2193c9cdc9f077061a3bbec099b9394..08bd03db94d8e031f87f1e6ed34d3f1e92a6565c 100644
--- a/config.py
+++ b/config.py
@@ -1,50 +1,71 @@
 """Configuration utilities for the psychology webinar bot."""
 from __future__ import annotations
 
 import json
 from pathlib import Path
-from typing import Any, Dict
+from typing import Any, Dict, Optional, Tuple
 
 # Bot credentials and application level constants
 BOT_TOKEN: str = "8334419696:AAFrH3-0nUn518KogBviZ-Qquvl6QtHwyDU"
-# Replace with the administrator chat ID that should have access to privileged commands.
-ADMIN_CHAT_ID: int = 123456789
+
+# Administrators who can access privileged commands.
+ADMINS: Tuple[Dict[str, Any], ...] = (
+    {
+        "chat_id": 7740254761,
+        "username": "z_ivan89",
+    },
+)
 
 # Storage locations
 DATA_DIR = Path("data")
 SETTINGS_FILE = DATA_DIR / "config.json"
 
 _DEFAULT_SETTINGS: Dict[str, Any] = {
     "topic": "Психологический вебинар",
     "description": "Авторский вебинар по психологии",
     "event_datetime": None,  # ISO formatted date time string
     "zoom_link": "",
     "payment_link": "",
 }
 
 
+def is_admin(chat_id: Optional[int] = None, username: Optional[str] = None) -> bool:
+    """Return True if provided identifiers match a known administrator."""
+
+    normalized_username = (username or "").lstrip("@").lower()
+    for admin in ADMINS:
+        admin_chat_id = admin.get("chat_id")
+        admin_username = (admin.get("username") or "").lstrip("@").lower()
+
+        if chat_id is not None and admin_chat_id == chat_id:
+            return True
+        if normalized_username and admin_username and normalized_username == admin_username:
+            return True
+    return False
+
+
 def ensure_data_dir() -> None:
     """Ensure that all required folders exist."""
     DATA_DIR.mkdir(parents=True, exist_ok=True)
 
 
 def load_settings() -> Dict[str, Any]:
     """Load the admin editable settings from disk."""
     ensure_data_dir()
     if not SETTINGS_FILE.exists():
         save_settings(_DEFAULT_SETTINGS)
         return dict(_DEFAULT_SETTINGS)
 
     with SETTINGS_FILE.open("r", encoding="utf-8") as fh:
         data = json.load(fh)
 
     merged = dict(_DEFAULT_SETTINGS)
     merged.update({k: v for k, v in data.items() if v is not None})
     return merged
 
 
 def save_settings(settings: Dict[str, Any]) -> None:
     """Persist settings to disk."""
     ensure_data_dir()
     with SETTINGS_FILE.open("w", encoding="utf-8") as fh:
         json.dump(settings, fh, ensure_ascii=False, indent=2)
diff --git a/handlers.py b/handlers.py
index 6a4f31dcfca4e87441f74a97b8202ef5b0f9da6c..d2b58dea74e4d5a5425e6ca6c746e8414ae3fbd3 100644
--- a/handlers.py
+++ b/handlers.py
@@ -1,52 +1,52 @@
 """User interaction handlers for the psychology webinar bot."""
 from __future__ import annotations
 
 import re
 
 from telegram import ReplyKeyboardMarkup, ReplyKeyboardRemove, Update
 from telegram.ext import (
     CommandHandler,
     ContextTypes,
     ConversationHandler,
     MessageHandler,
     filters,
 )
 
 import database
-from config import ADMIN_CHAT_ID, load_settings
+from config import is_admin, load_settings
 
 WAITING_EMAIL, WAITING_FORMAT = range(2)
 FREE_BUTTON = "🆓 Наблюдатель (бесплатно)"
 PAID_BUTTON = "💰 Участник с разбором (платно)"
 
 EMAIL_REGEX = re.compile(r"^[^@\s]+@[^@\s]+\.[^@\s]+$")
 
 
 async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
     user = update.effective_user
-    if user and user.id == ADMIN_CHAT_ID:
+    if user and is_admin(chat_id=user.id, username=user.username):
         from admin_panel import send_admin_panel
 
         await send_admin_panel(update, context)
         return ConversationHandler.END
 
     await update.message.reply_text(
         "Добро пожаловать на вебинар по психологии!\n"
         "Пожалуйста, укажите ваш e-mail для регистрации.",
         reply_markup=ReplyKeyboardRemove(),
     )
     return WAITING_EMAIL
 
 
 async def handle_email(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
     email = (update.message.text or "").strip()
     if not EMAIL_REGEX.match(email):
         await update.message.reply_text("Похоже, это не e-mail. Попробуйте снова.")
         return WAITING_EMAIL
 
     user = update.effective_user
     participant = database.Participant(
         name=user.full_name,
         username=f"@{user.username}" if user.username else "",
         chat_id=update.effective_chat.id,
         email=email,

