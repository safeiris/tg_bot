diff --git a/1.txt b/1.txt
deleted file mode 100644
index b2a824ec5419111f91d5b44c54ddd36ce95a5c38..0000000000000000000000000000000000000000
--- a/1.txt
+++ /dev/null
@@ -1,1613 +0,0 @@
-diff --git a/admin_panel.py b/admin_panel.py
-index 2931ad7229a8c3d1c4d737b99d0c58ef38326ba6..846f43a312febc92695b2ce07cf6266ddb37d2a3 100644
---- a/admin_panel.py
-+++ b/admin_panel.py
-@@ -1,493 +1,731 @@
--"""Administrative tools for configuring the webinar bot."""
-+"""Administrative tools for configuring the webinar bot with Google Sheets storage."""
- from __future__ import annotations
- 
-+import html
-+import re
- from datetime import datetime
--from pathlib import Path
--from urllib.parse import urlparse
-+from typing import Dict, Optional
-+from uuid import uuid4
- 
- from telegram import ReplyKeyboardMarkup, ReplyKeyboardRemove, Update
- from telegram.constants import ParseMode
- from telegram.ext import (
-     CommandHandler,
-     ContextTypes,
-     ConversationHandler,
-     MessageHandler,
-     filters,
- )
- 
-+from unidecode import unidecode
-+from zoneinfo import ZoneInfo
-+
- import database
--from config import is_admin, load_settings, update_settings
-+from config import TIMEZONE, is_admin, load_settings, update_settings
- from scheduler import ensure_scheduler_started, schedule_all_reminders
- 
--BUTTON_SET_DATE = "üìÜ –ò–∑–º–µ–Ω–∏—Ç—å –¥–∞—Ç—É"
- BUTTON_SET_TOPIC = "‚úèÔ∏è –ò–∑–º–µ–Ω–∏—Ç—å –Ω–∞–∑–≤–∞–Ω–∏–µ"
- BUTTON_SET_DESCRIPTION = "üìù –ò–∑–º–µ–Ω–∏—Ç—å –æ–ø–∏—Å–∞–Ω–∏–µ"
-+BUTTON_SET_DATE = "üìÜ –ò–∑–º–µ–Ω–∏—Ç—å –¥–∞—Ç—É"
- BUTTON_SET_ZOOM = "üîó –û–±–Ω–æ–≤–∏—Ç—å Zoom"
- BUTTON_SET_PAYMENT = "üí≥ –û–±–Ω–æ–≤–∏—Ç—å –æ–ø–ª–∞—Ç—É"
- BUTTON_EXPORT = "üì• –°–ø–∏—Å–æ–∫ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤"
- BUTTON_NOTIFY = "üì¢ –†–∞–∑–æ—Å–ª–∞—Ç—å –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ"
--BUTTON_SHOW_EVENT = "üóì –ü—Ä–æ—Å–º–æ—Ç—Ä —Ç–µ–∫—É—â–µ–≥–æ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è"
-+BUTTON_SHOW_EVENT = "üëÅ –¢–µ–∫—É—â–µ–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ"
-+BUTTON_NEW_EVENT = "üÜï –ù–æ–≤–æ–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ"
-+BUTTON_CREATE_NEW_PROMPT = "üÜï –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤–æ–µ"
-+BUTTON_CANCEL_ACTION = "–û—Ç–º–µ–Ω–∞"
- 
- MENU_KEYBOARD = ReplyKeyboardMarkup(
-     [
--        [BUTTON_SET_DATE, BUTTON_SET_TOPIC],
--        [BUTTON_SET_DESCRIPTION],
--        [BUTTON_SET_ZOOM, BUTTON_SET_PAYMENT],
--        [BUTTON_EXPORT, BUTTON_NOTIFY],
--        [BUTTON_SHOW_EVENT],
-+        [BUTTON_NEW_EVENT, BUTTON_SHOW_EVENT],
-+        [BUTTON_SET_TOPIC, BUTTON_SET_DESCRIPTION],
-+        [BUTTON_SET_DATE, BUTTON_SET_ZOOM],
-+        [BUTTON_SET_PAYMENT, BUTTON_EXPORT],
-+        [BUTTON_NOTIFY],
-     ],
-     resize_keyboard=True,
- )
- 
--STATE_TOPIC, STATE_DATE, STATE_ZOOM, STATE_PAYMENT, STATE_NOTIFY, STATE_DESCRIPTION = range(6)
-+(
-+    STATE_TOPIC,
-+    STATE_DATE,
-+    STATE_ZOOM,
-+    STATE_PAYMENT,
-+    STATE_NOTIFY,
-+    STATE_DESCRIPTION,
-+    STATE_DECIDE_NEW_EVENT,
-+    STATE_NEW_EVENT_TITLE,
-+    STATE_NEW_EVENT_DESCRIPTION,
-+    STATE_NEW_EVENT_DATETIME,
-+    STATE_NEW_EVENT_ZOOM,
-+    STATE_NEW_EVENT_PAYMENT,
-+) = range(12)
- 
- CANCEL_TEXT = "–æ—Ç–º–µ–Ω–∞"
- CLEAR_TEXT = "–æ—á–∏—Å—Ç–∏—Ç—å"
-+SKIP_TEXT = "–ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å"
- TOPIC_MAX_LENGTH = 200
-+MAX_SLUG_LENGTH = 30
- 
-+TZ = ZoneInfo(TIMEZONE)
-+MISSING_VALUE = "‚ùóÔ∏è–ù–µ —É–∫–∞–∑–∞–Ω–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º"
- 
--def _normalize_command_text(text: str | None) -> str:
-+
-+def _normalize_command_text(text: Optional[str]) -> str:
-     return (text or "").strip().lower()
- 
- 
--def _is_cancel(text: str | None) -> bool:
-+def _is_cancel(text: Optional[str]) -> bool:
-     return _normalize_command_text(text) == CANCEL_TEXT
- 
- 
--def _is_clear(text: str | None) -> bool:
-+def _is_clear(text: Optional[str]) -> bool:
-     return _normalize_command_text(text) == CLEAR_TEXT
- 
- 
--def _is_valid_url(value: str) -> bool:
--    parsed = urlparse(value)
--    return bool(parsed.scheme in {"http", "https"} and parsed.netloc)
-+def _is_skip(text: Optional[str]) -> bool:
-+    return _normalize_command_text(text) == SKIP_TEXT
- 
- 
--MISSING_VALUE = "‚ùóÔ∏è–ù–µ —É–∫–∞–∑–∞–Ω–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º"
--_MONTH_NAMES = [
--    "",
--    "—è–Ω–≤–∞—Ä—è",
--    "—Ñ–µ–≤—Ä–∞–ª—è",
--    "–º–∞—Ä—Ç–∞",
--    "–∞–ø—Ä–µ–ª—è",
--    "–º–∞—è",
--    "–∏—é–Ω—è",
--    "–∏—é–ª—è",
--    "–∞–≤–≥—É—Å—Ç–∞",
--    "—Å–µ–Ω—Ç—è–±—Ä—è",
--    "–æ–∫—Ç—è–±—Ä—è",
--    "–Ω–æ—è–±—Ä—è",
--    "–¥–µ–∫–∞–±—Ä—è",
--]
--
--
--def _is_admin(update: Update) -> bool:
-+async def _ensure_admin(update: Update, *, message: str = "–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.") -> bool:
-     user = update.effective_user
--    return bool(user and is_admin(chat_id=user.id, username=user.username))
-+    if user and is_admin(chat_id=user.id, username=user.username):
-+        return True
-+    if update.message:
-+        await update.message.reply_text(message)
-+    else:
-+        await update.effective_chat.send_message(message)
-+    return False
- 
- 
--def _format_value(value) -> str:
--    if value is None:
--        return MISSING_VALUE
--    if isinstance(value, str):
--        stripped = value.strip()
--        if not stripped:
--            return MISSING_VALUE
--        return stripped
--    return str(value)
-+def _slugify_topic(topic: str) -> str:
-+    normalized = unidecode(topic or "").lower()
-+    normalized = re.sub(r"[^a-z0-9]+", "-", normalized).strip("-")
-+    if not normalized:
-+        normalized = "event"
-+    return normalized[:MAX_SLUG_LENGTH]
- 
- 
--def _format_datetime(dt: datetime) -> str:
--    if 1 <= dt.month <= 12:
--        month = _MONTH_NAMES[dt.month]
--    else:
--        month = dt.strftime("%B")
--    return f"{dt.day} {month} {dt.year}, {dt.strftime('%H:%M')}"
-+def _generate_sheet_name(topic: str, event_dt: datetime) -> str:
-+    base_slug = _slugify_topic(topic)
-+    date_part = event_dt.strftime("%Y-%m-%d")
-+    candidate = f"{date_part}__{base_slug}"
-+    suffix = 1
-+    while database.get_sheet_by_name(candidate) is not None:
-+        suffix += 1
-+        trimmed_slug = base_slug[: max(1, MAX_SLUG_LENGTH - len(f"-{suffix}"))]
-+        candidate = f"{date_part}__{trimmed_slug}-{suffix}"
-+    return candidate
- 
- 
--def _try_parse_separate_datetime(date_str: str | None, time_str: str | None) -> datetime | None:
--    if not date_str:
--        return None
-+def _generate_event_id() -> str:
-+    return uuid4().hex[:12]
- 
--    date_str = date_str.strip()
--    time_str = (time_str or "").strip()
- 
--    if time_str:
--        candidate = f"{date_str} {time_str}".strip()
--        for fmt in ("%Y-%m-%d %H:%M", "%d.%m.%Y %H:%M", "%d.%m.%y %H:%M"):
--            try:
--                return datetime.strptime(candidate, fmt)
--            except ValueError:
--                continue
--    else:
--        for fmt in ("%Y-%m-%d", "%d.%m.%Y", "%d.%m.%y"):
--            try:
--                return datetime.strptime(date_str, fmt)
--            except ValueError:
--                continue
--    return None
-+def _parse_datetime(text: str) -> datetime:
-+    text = (text or "").strip()
-+    formats = ["%d.%m.%Y %H:%M", "%d.%m %H:%M", "%Y-%m-%d %H:%M"]
-+    for fmt in formats:
-+        try:
-+            dt = datetime.strptime(text, fmt)
-+            if fmt == "%d.%m %H:%M":
-+                dt = dt.replace(year=datetime.now(TZ).year)
-+            return dt.replace(tzinfo=TZ)
-+        except ValueError:
-+            continue
-+    raise ValueError("invalid format")
- 
- 
--async def _ensure_admin(update: Update, *, message: str = "–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.") -> bool:
--    if _is_admin(update):
--        return True
--    if update.message:
--        await update.message.reply_text(message)
--    else:
--        await update.effective_chat.send_message(message)
--    return False
-+def _format_datetime(dt: Optional[datetime]) -> str:
-+    if not dt:
-+        return MISSING_VALUE
-+    local_dt = dt.astimezone(TZ)
-+    month_names = [
-+        "",
-+        "—è–Ω–≤–∞—Ä—è",
-+        "—Ñ–µ–≤—Ä–∞–ª—è",
-+        "–º–∞—Ä—Ç–∞",
-+        "–∞–ø—Ä–µ–ª—è",
-+        "–º–∞—è",
-+        "–∏—é–Ω—è",
-+        "–∏—é–ª—è",
-+        "–∞–≤–≥—É—Å—Ç–∞",
-+        "—Å–µ–Ω—Ç—è–±—Ä—è",
-+        "–æ–∫—Ç—è–±—Ä—è",
-+        "–Ω–æ—è–±—Ä—è",
-+        "–¥–µ–∫–∞–±—Ä—è",
-+    ]
-+    month_name = month_names[local_dt.month] if 1 <= local_dt.month <= 12 else local_dt.strftime("%B")
-+    return f"{local_dt.day} {month_name} {local_dt.year}, {local_dt.strftime('%H:%M')}"
- 
- 
--async def send_admin_panel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
--    settings = load_settings()
--    text = (
--        "<b>–ü–∞–Ω–µ–ª—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞</b>\n\n"
--        f"–ù–∞–∑–≤–∞–Ω–∏–µ: {_format_value(settings.get('topic'))}\n"
--        f"–û–ø–∏—Å–∞–Ω–∏–µ: {_format_value(settings.get('description'))}\n"
--        f"–î–∞—Ç–∞: {_format_value(settings.get('event_datetime'))}\n"
--        f"Zoom: {_format_value(settings.get('zoom_link'))}\n"
--        f"–û–ø–ª–∞—Ç–∞: {_format_value(settings.get('payment_link'))}"
--    )
--    if update.message:
--        await update.message.reply_text(text, parse_mode=ParseMode.HTML, reply_markup=MENU_KEYBOARD)
--    else:
--        await update.effective_chat.send_message(text, parse_mode=ParseMode.HTML, reply_markup=MENU_KEYBOARD)
-+def _event_datetime(settings: Dict[str, object]) -> Optional[datetime]:
-+    event_iso = settings.get("current_event_datetime")
-+    if not event_iso:
-+        return None
-+    try:
-+        return datetime.fromisoformat(str(event_iso))
-+    except ValueError:
-+        return None
- 
- 
--async def show_current_event(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
--    if not await _ensure_admin(update):
--        return ConversationHandler.END
-+def _event_has_started(settings: Dict[str, object]) -> bool:
-+    dt = _event_datetime(settings)
-+    if not dt:
-+        return False
-+    now = datetime.now(TZ)
-+    return now >= dt
- 
--    settings = load_settings()
- 
-+def _format_value(value: Optional[object]) -> str:
-+    if value is None:
-+        return MISSING_VALUE
-+    if isinstance(value, str):
-+        stripped = value.strip()
-+        return stripped if stripped else MISSING_VALUE
-+    return str(value)
-+
-+
-+def _build_event_card(settings: Dict[str, object]) -> str:
-     topic = _format_value(settings.get("topic"))
-     description = _format_value(settings.get("description"))
-     zoom_link = _format_value(settings.get("zoom_link"))
-     payment_link = _format_value(settings.get("payment_link"))
- 
--    event_dt_text = MISSING_VALUE
--    event_dt_obj: datetime | None = None
-+    dt = _event_datetime(settings)
-+    dt_text = _format_datetime(dt)
-+
-+    lines = ["<b>–¢–µ–∫—É—â–µ–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ</b>"]
-+    lines.append(f"üéì –ù–∞–∑–≤–∞–Ω–∏–µ: {html.escape(topic)}")
-+    lines.append(f"üìù –û–ø–∏—Å–∞–Ω–∏–µ: {html.escape(description)}")
-+    lines.append(f"üìÖ –î–∞—Ç–∞ –∏ –≤—Ä–µ–º—è: {html.escape(dt_text)}")
-+    lines.append(f"üîó Zoom: {html.escape(zoom_link)}")
-+    lines.append(f"üí≥ –û–ø–ª–∞—Ç–∞: {html.escape(payment_link)}")
-+    lines.append(f"üåç –ß–∞—Å–æ–≤–æ–π –ø–æ—è—Å: {html.escape(TIMEZONE)}")
- 
--    event_iso = settings.get("event_datetime")
--    if event_iso:
-+    sheet_name = settings.get("current_event_sheet_name")
-+    sheet_gid = settings.get("current_event_sheet_gid")
-+    if sheet_name:
-         try:
--            event_dt_obj = datetime.fromisoformat(event_iso)
--            event_dt_text = _format_datetime(event_dt_obj)
--        except ValueError:
--            event_dt_text = event_iso
-+            sheet_link = database.get_sheet_link(sheet_name, sheet_gid)
-+            lines.append(f"üìä –£—á–∞—Å—Ç–Ω–∏–∫–∏: <a href=\"{sheet_link}\">–û—Ç–∫—Ä—ã—Ç—å –ª–∏—Å—Ç</a>")
-+        except RuntimeError:
-+            lines.append("üìä –£—á–∞—Å—Ç–Ω–∏–∫–∏: –ª–∏—Å—Ç –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω")
-     else:
--        event_date = settings.get("event_date")
--        event_time = settings.get("event_time")
--        combined = " ".join(
--            part.strip()
--            for part in (event_date or "", event_time or "")
--            if part and part.strip()
-+        lines.append("üìä –£—á–∞—Å—Ç–Ω–∏–∫–∏: –ª–∏—Å—Ç –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω")
-+
-+    if _event_has_started(settings):
-+        lines.append("\n‚ö†Ô∏è –ú–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ —É–∂–µ –Ω–∞—á–∞–ª–æ—Å—å. –ò–∑–º–µ–Ω–µ–Ω–∏—è –Ω–µ–≤–æ–∑–º–æ–∂–Ω—ã.")
-+
-+    return "\n".join(lines)
-+
-+
-+async def _send_event_card(update: Update, settings: Optional[Dict[str, object]] = None) -> None:
-+    if settings is None:
-+        settings = load_settings()
-+    text = _build_event_card(settings)
-+    if update.message:
-+        await update.message.reply_text(
-+            text,
-+            parse_mode=ParseMode.HTML,
-+            reply_markup=MENU_KEYBOARD,
-+            disable_web_page_preview=True,
-+        )
-+    else:
-+        await update.effective_chat.send_message(
-+            text,
-+            parse_mode=ParseMode.HTML,
-+            reply_markup=MENU_KEYBOARD,
-+            disable_web_page_preview=True,
-         )
--        if combined:
--            event_dt_text = combined
--            event_dt_obj = _try_parse_separate_datetime(event_date, event_time)
--
--    lines = [
--        f"üéì –ù–∞–∑–≤–∞–Ω–∏–µ: {topic}",
--        f"üìù –û–ø–∏—Å–∞–Ω–∏–µ: {description}",
--        f"üìÖ –î–∞—Ç–∞ –∏ –≤—Ä–µ–º—è: {event_dt_text if event_dt_text.strip() else MISSING_VALUE}",
--        f"üîó Zoom: {zoom_link}",
--        f"üí≥ –°—Å—ã–ª–∫–∞ –Ω–∞ –æ–ø–ª–∞—Ç—É: {payment_link}",
--    ]
- 
--    if "timezone" in settings:
--        timezone_value = _format_value(settings.get("timezone"))
--        lines.append(f"üåç –ß–∞—Å–æ–≤–æ–π –ø–æ—è—Å: {timezone_value}")
--
--    known_fields = {
--        "topic",
--        "description",
--        "event_datetime",
--        "event_date",
--        "event_time",
--        "zoom_link",
--        "payment_link",
--        "timezone",
--    }
--    for key in sorted(settings):
--        if key in known_fields:
--            continue
--        value_text = _format_value(settings.get(key))
--        label = key.replace("_", " ").capitalize()
--        lines.append(f"‚Ä¢ {label}: {value_text}")
- 
--    message = "\n".join(lines)
-+async def send_admin_panel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
-+    await _send_event_card(update)
-+
-+
-+async def _maybe_require_new_event(update: Update) -> Optional[Dict[str, object]]:
-+    settings = load_settings()
-+    if not settings.get("current_event_id") or not settings.get("current_event_sheet_name"):
-+        await _prompt_new_event_creation(update, started=False)
-+        return None
-+    if _event_has_started(settings):
-+        await _prompt_new_event_creation(update, started=True)
-+        return None
-+    return settings
- 
--    if event_dt_obj and event_dt_obj < datetime.now(event_dt_obj.tzinfo):
--        message += "\n\n‚ö†Ô∏è –ú–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ —É–∂–µ –ø—Ä–æ—à–ª–æ."
- 
-+async def _prompt_new_event_creation(update: Update, *, started: bool) -> None:
-+    keyboard = ReplyKeyboardMarkup(
-+        [[BUTTON_CREATE_NEW_PROMPT], [BUTTON_CANCEL_ACTION]], resize_keyboard=True
-+    )
-+    if started:
-+        message = (
-+            "–¢–µ–∫—É—â–µ–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ —É–∂–µ –Ω–∞—á–∞–ª–æ—Å—å. –î–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏–π —Å–æ–∑–¥–∞–π—Ç–µ –Ω–æ–≤–æ–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ."
-+        )
-+    else:
-+        message = "–ê–∫—Ç–∏–≤–Ω–æ–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–æ. –°–æ–∑–¥–∞–π—Ç–µ –Ω–æ–≤–æ–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ."
-     if update.message:
--        await update.message.reply_text(message, reply_markup=MENU_KEYBOARD)
-+        await update.message.reply_text(message, reply_markup=keyboard)
-     else:
--        await update.effective_chat.send_message(message, reply_markup=MENU_KEYBOARD)
-+        await update.effective_chat.send_message(message, reply_markup=keyboard)
- 
-+
-+async def show_current_event(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-+    if not await _ensure_admin(update):
-+        return ConversationHandler.END
-+    await _send_event_card(update)
-     return ConversationHandler.END
- 
- 
- async def admin_command_entry(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-     if not await _ensure_admin(update, message="–≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É."):
-         return ConversationHandler.END
-     await send_admin_panel(update, context)
-     return ConversationHandler.END
- 
- 
- async def set_topic_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-     if not await _ensure_admin(update):
-         return ConversationHandler.END
-+    settings = await _maybe_require_new_event(update)
-+    if settings is None:
-+        return STATE_DECIDE_NEW_EVENT
-     await update.message.reply_text(
--        "–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è (–¥–æ 200 —Å–∏–º–≤–æ–ª–æ–≤).\n"
--        "–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã: –û—Ç–º–µ–Ω–∞.",
-+        "–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è (–¥–æ 200 —Å–∏–º–≤–æ–ª–æ–≤).\n–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã: –û—Ç–º–µ–Ω–∞.",
-         reply_markup=ReplyKeyboardRemove(),
-     )
-     return STATE_TOPIC
- 
- 
- async def set_topic_finish(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-     if not await _ensure_admin(update):
-         return ConversationHandler.END
-     text = (update.message.text or "").strip()
--
-     if _is_cancel(text):
-         await update.message.reply_text("–ò–∑–º–µ–Ω–µ–Ω–∏–µ –Ω–∞–∑–≤–∞–Ω–∏—è –æ—Ç–º–µ–Ω–µ–Ω–æ.", reply_markup=MENU_KEYBOARD)
-         return ConversationHandler.END
--
-     if not text:
-         await update.message.reply_text("–ù–∞–∑–≤–∞–Ω–∏–µ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")
-         return STATE_TOPIC
--
-     if len(text) > TOPIC_MAX_LENGTH:
-         await update.message.reply_text(
-             f"–ù–∞–∑–≤–∞–Ω–∏–µ —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω–æ–µ. –ú–∞–∫—Å–∏–º—É–º {TOPIC_MAX_LENGTH} —Å–∏–º–≤–æ–ª–æ–≤."
-         )
-         return STATE_TOPIC
--
--    update_settings(topic=text)
--    await show_current_event(update, context)
-+    settings = update_settings(topic=text)
-     await update.message.reply_text("‚úÖ –ù–∞–∑–≤–∞–Ω–∏–µ –æ–±–Ω–æ–≤–ª–µ–Ω–æ.", reply_markup=MENU_KEYBOARD)
-+    await _send_event_card(update, settings)
-     return ConversationHandler.END
- 
- 
- async def set_description_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-     if not await _ensure_admin(update):
-         return ConversationHandler.END
-+    settings = await _maybe_require_new_event(update)
-+    if settings is None:
-+        return STATE_DECIDE_NEW_EVENT
-     await update.message.reply_text(
--        "–û—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è.\n"
--        "–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã: –û—Ç–º–µ–Ω–∞, –û—á–∏—Å—Ç–∏—Ç—å.",
-+        "–û—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è.\n–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã: –û—Ç–º–µ–Ω–∞, –û—á–∏—Å—Ç–∏—Ç—å.",
-         reply_markup=ReplyKeyboardRemove(),
-     )
-     return STATE_DESCRIPTION
- 
- 
- async def set_description_finish(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-     if not await _ensure_admin(update):
-         return ConversationHandler.END
--
-     raw_text = update.message.text or ""
-     if _is_cancel(raw_text):
-         await update.message.reply_text("–ò–∑–º–µ–Ω–µ–Ω–∏–µ –æ–ø–∏—Å–∞–Ω–∏—è –æ—Ç–º–µ–Ω–µ–Ω–æ.", reply_markup=MENU_KEYBOARD)
-         return ConversationHandler.END
--
-     if _is_clear(raw_text):
--        update_settings(description=None)
--        await show_current_event(update, context)
-+        settings = update_settings(description="")
-         await update.message.reply_text("–û–ø–∏—Å–∞–Ω–∏–µ –æ—á–∏—â–µ–Ω–æ.", reply_markup=MENU_KEYBOARD)
-+        await _send_event_card(update, settings)
-         return ConversationHandler.END
--
-     stripped = raw_text.strip()
-     if not stripped:
-         await update.message.reply_text(
-             "–û–ø–∏—Å–∞–Ω–∏–µ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º. –í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –û—á–∏—Å—Ç–∏—Ç—å."
-         )
-         return STATE_DESCRIPTION
--
--    update_settings(description=stripped)
--    await show_current_event(update, context)
-+    settings = update_settings(description=stripped)
-     await update.message.reply_text("‚úÖ –û–ø–∏—Å–∞–Ω–∏–µ –æ–±–Ω–æ–≤–ª–µ–Ω–æ.", reply_markup=MENU_KEYBOARD)
-+    await _send_event_card(update, settings)
-     return ConversationHandler.END
- 
- 
--def _parse_datetime(text: str) -> datetime:
--    text = text.strip()
--    formats = ["%d.%m.%Y %H:%M", "%d.%m %H:%M"]
--    for fmt in formats:
--        try:
--            dt = datetime.strptime(text, fmt)
--            if fmt == "%d.%m %H:%M":
--                dt = dt.replace(year=datetime.now().year)
--            return dt
--        except ValueError:
--            continue
--    raise ValueError("invalid format")
--
--
- async def set_date_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-     if not await _ensure_admin(update):
-         return ConversationHandler.END
-+    settings = await _maybe_require_new_event(update)
-+    if settings is None:
-+        return STATE_DECIDE_NEW_EVENT
-     await update.message.reply_text(
--        "–í–≤–µ–¥–∏—Ç–µ –¥–∞—Ç—É –∏ –≤—Ä–µ–º—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ –î–î.–ú–ú.–ì–ì–ì–ì –ß–ß:–ú–ú –∏–ª–∏ –î–î.–ú–ú –ß–ß:–ú–ú",
-+        "–í–≤–µ–¥–∏—Ç–µ –¥–∞—Ç—É –∏ –≤—Ä–µ–º—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ –î–î.–ú–ú.–ì–ì–ì–ì –ß–ß:–ú–ú –∏–ª–∏ –î–î.–ú–ú –ß–ß:–ú–ú.",
-         reply_markup=ReplyKeyboardRemove(),
-     )
-     return STATE_DATE
- 
- 
- async def set_date_finish(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-     if not await _ensure_admin(update):
-         return ConversationHandler.END
-     text = update.message.text or ""
-     try:
-         event_dt = _parse_datetime(text)
-     except ValueError:
-         await update.message.reply_text("–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å –¥–∞—Ç—É. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")
-         return STATE_DATE
--
--    update_settings(event_datetime=event_dt.isoformat())
-+    settings = update_settings(current_event_datetime=event_dt.isoformat())
-     ensure_scheduler_started()
-     schedule_all_reminders(context.application)
--    await show_current_event(update, context)
-     await update.message.reply_text("–î–∞—Ç–∞ –≤–µ–±–∏–Ω–∞—Ä–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∞.", reply_markup=MENU_KEYBOARD)
-+    await _send_event_card(update, settings)
-     return ConversationHandler.END
- 
- 
-+def _is_valid_url(value: str) -> bool:
-+    pattern = re.compile(r"^https?://.+$", re.IGNORECASE)
-+    return bool(pattern.match(value))
-+
-+
- async def set_zoom_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-     if not await _ensure_admin(update):
-         return ConversationHandler.END
-+    settings = await _maybe_require_new_event(update)
-+    if settings is None:
-+        return STATE_DECIDE_NEW_EVENT
-     await update.message.reply_text(
-         "–û—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–æ–≤—É—é Zoom-—Å—Å—ã–ª–∫—É.\n–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã: –û—Ç–º–µ–Ω–∞, –û—á–∏—Å—Ç–∏—Ç—å.",
-         reply_markup=ReplyKeyboardRemove(),
-     )
-     return STATE_ZOOM
- 
- 
- async def set_zoom_finish(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-     if not await _ensure_admin(update):
-         return ConversationHandler.END
-     text = update.message.text or ""
--
-     if _is_cancel(text):
-         await update.message.reply_text("–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ Zoom-—Å—Å—ã–ª–∫–∏ –æ—Ç–º–µ–Ω–µ–Ω–æ.", reply_markup=MENU_KEYBOARD)
-         return ConversationHandler.END
--
--    if _is_clear(text):
--        update_settings(zoom_link=None)
--        await show_current_event(update, context)
-+    if _is_clear(text) or _is_skip(text):
-+        settings = update_settings(zoom_link="")
-         await update.message.reply_text("–°—Å—ã–ª–∫–∞ Zoom –æ—á–∏—â–µ–Ω–∞.", reply_markup=MENU_KEYBOARD)
-+        await _send_event_card(update, settings)
-         schedule_all_reminders(context.application)
-         return ConversationHandler.END
--
-     link = text.strip()
--    if not link or not _is_valid_url(link):
-+    if not _is_valid_url(link):
-         await update.message.reply_text(
--            "–£–∫–∞–∂–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—É—é —Å—Å—ã–ª–∫—É (http/https) –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—ã –û—Ç–º–µ–Ω–∞/–û—á–∏—Å—Ç–∏—Ç—å."
-+            "–£–∫–∞–∂–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—É—é —Å—Å—ã–ª–∫—É (http/https) –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—ã –û—Ç–º–µ–Ω–∞/–û—á–∏—Å—Ç–∏—Ç—å/–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å."
-         )
-         return STATE_ZOOM
--
--    update_settings(zoom_link=link)
--    await show_current_event(update, context)
-+    settings = update_settings(zoom_link=link)
-     await update.message.reply_text("–°—Å—ã–ª–∫–∞ Zoom –æ–±–Ω–æ–≤–ª–µ–Ω–∞.", reply_markup=MENU_KEYBOARD)
-+    await _send_event_card(update, settings)
-     schedule_all_reminders(context.application)
-     return ConversationHandler.END
- 
- 
- async def set_payment_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-     if not await _ensure_admin(update):
-         return ConversationHandler.END
-+    settings = await _maybe_require_new_event(update)
-+    if settings is None:
-+        return STATE_DECIDE_NEW_EVENT
-     await update.message.reply_text(
--        "–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Å—Å—ã–ª–∫—É –Ω–∞ –æ–ø–ª–∞—Ç—É (http/https).\n–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã: –û—Ç–º–µ–Ω–∞, –û—á–∏—Å—Ç–∏—Ç—å.",
-+        "–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Å—Å—ã–ª–∫—É –Ω–∞ –æ–ø–ª–∞—Ç—É (http/https).\n–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã: –û—Ç–º–µ–Ω–∞, –û—á–∏—Å—Ç–∏—Ç—å, –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å.",
-         reply_markup=ReplyKeyboardRemove(),
-     )
-     return STATE_PAYMENT
- 
- 
- async def set_payment_finish(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-     if not await _ensure_admin(update):
-         return ConversationHandler.END
-     text = update.message.text or ""
--
-     if _is_cancel(text):
-         await update.message.reply_text("–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Å—ã–ª–∫–∏ –Ω–∞ –æ–ø–ª–∞—Ç—É –æ—Ç–º–µ–Ω–µ–Ω–æ.", reply_markup=MENU_KEYBOARD)
-         return ConversationHandler.END
--
--    if _is_clear(text):
--        update_settings(payment_link=None)
--        await show_current_event(update, context)
-+    if _is_clear(text) or _is_skip(text):
-+        settings = update_settings(payment_link="")
-         await update.message.reply_text("–°—Å—ã–ª–∫–∞ –Ω–∞ –æ–ø–ª–∞—Ç—É –æ—á–∏—â–µ–Ω–∞.", reply_markup=MENU_KEYBOARD)
-+        await _send_event_card(update, settings)
-         return ConversationHandler.END
--
-     link = text.strip()
--    if not link or not _is_valid_url(link):
-+    if not _is_valid_url(link):
-         await update.message.reply_text(
--            "–£–∫–∞–∂–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—É—é —Å—Å—ã–ª–∫—É (http/https) –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—ã –û—Ç–º–µ–Ω–∞/–û—á–∏—Å—Ç–∏—Ç—å."
-+            "–£–∫–∞–∂–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—É—é —Å—Å—ã–ª–∫—É (http/https) –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—ã –û—Ç–º–µ–Ω–∞/–û—á–∏—Å—Ç–∏—Ç—å/–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å."
-         )
-         return STATE_PAYMENT
--
--    update_settings(payment_link=link)
--    await show_current_event(update, context)
-+    settings = update_settings(payment_link=link)
-     await update.message.reply_text("–°—Å—ã–ª–∫–∞ –Ω–∞ –æ–ø–ª–∞—Ç—É –æ–±–Ω–æ–≤–ª–µ–Ω–∞.", reply_markup=MENU_KEYBOARD)
-+    await _send_event_card(update, settings)
-     return ConversationHandler.END
- 
- 
- async def export_participants(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-     if not await _ensure_admin(update):
-         return ConversationHandler.END
-+    try:
-+        sheet_link = database.get_sheet_link()
-+    except RuntimeError:
-+        await update.message.reply_text(
-+            "–ê–∫—Ç–∏–≤–Ω—ã–π –ª–∏—Å—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω. –°–Ω–∞—á–∞–ª–∞ —Å–æ–∑–¥–∞–π—Ç–µ –Ω–æ–≤–æ–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ.",
-+            reply_markup=MENU_KEYBOARD,
-+        )
-+        return ConversationHandler.END
-+    await update.message.reply_text(
-+        f"üìä –°–ø–∏—Å–æ–∫ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤: {sheet_link}", reply_markup=MENU_KEYBOARD, disable_web_page_preview=True
-+    )
-     path = database.export_database()
--    await update.message.reply_document(document=path.read_bytes(), filename=Path(path).name)
-+    await update.message.reply_document(document=path.read_bytes(), filename=path.name)
-     return ConversationHandler.END
- 
- 
- async def notify_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-     if not await _ensure_admin(update):
-         return ConversationHandler.END
-     await update.message.reply_text(
-         "–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è, –∫–æ—Ç–æ—Ä—ã–π –±—É–¥–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –≤—Å–µ–º —É—á–∞—Å—Ç–Ω–∏–∫–∞–º:",
-         reply_markup=ReplyKeyboardRemove(),
-     )
-     return STATE_NOTIFY
- 
- 
- async def notify_finish(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-     if not await _ensure_admin(update):
-         return ConversationHandler.END
-     text = update.message.text or ""
-     participants = database.list_chat_ids()
-     for chat_id in participants:
-         await context.bot.send_message(chat_id=chat_id, text=text)
-     await update.message.reply_text("–†–∞—Å—Å—ã–ª–∫–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞.", reply_markup=MENU_KEYBOARD)
-     return ConversationHandler.END
- 
- 
-+async def start_new_event_flow(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-+    if not await _ensure_admin(update):
-+        return ConversationHandler.END
-+    context.user_data["new_event_data"] = {}
-+    await update.message.reply_text(
-+        "–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è.", reply_markup=ReplyKeyboardRemove()
-+    )
-+    return STATE_NEW_EVENT_TITLE
-+
-+
-+async def handle_new_event_decision(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-+    if not await _ensure_admin(update):
-+        return ConversationHandler.END
-+    text = (update.message.text or "").strip()
-+    if text == BUTTON_CREATE_NEW_PROMPT or text == BUTTON_NEW_EVENT:
-+        return await start_new_event_flow(update, context)
-+    await update.message.reply_text("–°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è –æ—Ç–º–µ–Ω–µ–Ω–æ.", reply_markup=MENU_KEYBOARD)
-+    return ConversationHandler.END
-+
-+
-+async def new_event_title(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-+    if not await _ensure_admin(update):
-+        return ConversationHandler.END
-+    text = (update.message.text or "").strip()
-+    if _is_cancel(text):
-+        await update.message.reply_text("–°–æ–∑–¥–∞–Ω–∏–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è –æ—Ç–º–µ–Ω–µ–Ω–æ.", reply_markup=MENU_KEYBOARD)
-+        context.user_data.pop("new_event_data", None)
-+        return ConversationHandler.END
-+    if not text:
-+        await update.message.reply_text("–ù–∞–∑–≤–∞–Ω–∏–µ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")
-+        return STATE_NEW_EVENT_TITLE
-+    context.user_data.setdefault("new_event_data", {})["topic"] = text
-+    await update.message.reply_text(
-+        "–û—Ç–ø—Ä–∞–≤—å—Ç–µ –æ–ø–∏—Å–∞–Ω–∏–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è.\n–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã: –û—Ç–º–µ–Ω–∞, –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å.",
-+        reply_markup=ReplyKeyboardRemove(),
-+    )
-+    return STATE_NEW_EVENT_DESCRIPTION
-+
-+
-+async def new_event_description(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-+    if not await _ensure_admin(update):
-+        return ConversationHandler.END
-+    text = update.message.text or ""
-+    data = context.user_data.setdefault("new_event_data", {})
-+    if _is_cancel(text):
-+        await update.message.reply_text("–°–æ–∑–¥–∞–Ω–∏–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è –æ—Ç–º–µ–Ω–µ–Ω–æ.", reply_markup=MENU_KEYBOARD)
-+        context.user_data.pop("new_event_data", None)
-+        return ConversationHandler.END
-+    if _is_skip(text):
-+        data["description"] = ""
-+    else:
-+        data["description"] = text.strip()
-+    await update.message.reply_text(
-+        "–í–≤–µ–¥–∏—Ç–µ –¥–∞—Ç—É –∏ –≤—Ä–µ–º—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ –î–î.–ú–ú.–ì–ì–ì–ì –ß–ß:–ú–ú –∏–ª–∏ –î–î.–ú–ú –ß–ß:–ú–ú.",
-+        reply_markup=ReplyKeyboardRemove(),
-+    )
-+    return STATE_NEW_EVENT_DATETIME
-+
-+
-+async def new_event_datetime(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-+    if not await _ensure_admin(update):
-+        return ConversationHandler.END
-+    text = update.message.text or ""
-+    try:
-+        event_dt = _parse_datetime(text)
-+    except ValueError:
-+        await update.message.reply_text("–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å –¥–∞—Ç—É. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")
-+        return STATE_NEW_EVENT_DATETIME
-+    context.user_data.setdefault("new_event_data", {})["datetime"] = event_dt
-+    await update.message.reply_text(
-+        "–£–∫–∞–∂–∏—Ç–µ Zoom-—Å—Å—ã–ª–∫—É. –î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã: –û—Ç–º–µ–Ω–∞, –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å.",
-+        reply_markup=ReplyKeyboardRemove(),
-+    )
-+    return STATE_NEW_EVENT_ZOOM
-+
-+
-+async def new_event_zoom(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-+    if not await _ensure_admin(update):
-+        return ConversationHandler.END
-+    text = update.message.text or ""
-+    data = context.user_data.setdefault("new_event_data", {})
-+    if _is_cancel(text):
-+        await update.message.reply_text("–°–æ–∑–¥–∞–Ω–∏–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è –æ—Ç–º–µ–Ω–µ–Ω–æ.", reply_markup=MENU_KEYBOARD)
-+        context.user_data.pop("new_event_data", None)
-+        return ConversationHandler.END
-+    if _is_skip(text) or _is_clear(text):
-+        data["zoom_link"] = ""
-+    else:
-+        link = text.strip()
-+        if not _is_valid_url(link):
-+            await update.message.reply_text(
-+                "–£–∫–∞–∂–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—É—é —Å—Å—ã–ª–∫—É (http/https) –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—ã –û—Ç–º–µ–Ω–∞/–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å."
-+            )
-+            return STATE_NEW_EVENT_ZOOM
-+        data["zoom_link"] = link
-+    await update.message.reply_text(
-+        "–£–∫–∞–∂–∏—Ç–µ —Å—Å—ã–ª–∫—É –Ω–∞ –æ–ø–ª–∞—Ç—É. –î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã: –û—Ç–º–µ–Ω–∞, –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å.",
-+        reply_markup=ReplyKeyboardRemove(),
-+    )
-+    return STATE_NEW_EVENT_PAYMENT
-+
-+
-+async def _finalize_new_event(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-+    data = context.user_data.get("new_event_data") or {}
-+    topic = data.get("topic")
-+    event_dt: Optional[datetime] = data.get("datetime")
-+    if not topic or not event_dt:
-+        await update.message.reply_text(
-+            "–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.",
-+            reply_markup=MENU_KEYBOARD,
-+        )
-+        context.user_data.pop("new_event_data", None)
-+        return ConversationHandler.END
-+
-+    sheet_name = _generate_sheet_name(topic, event_dt)
-+    worksheet = database.get_or_create_sheet(sheet_name)
-+    event_id = _generate_event_id()
-+
-+    settings = update_settings(
-+        topic=topic,
-+        description=data.get("description", ""),
-+        zoom_link=data.get("zoom_link", ""),
-+        payment_link=data.get("payment_link", ""),
-+        current_event_id=event_id,
-+        current_event_sheet_name=worksheet.title,
-+        current_event_sheet_gid=worksheet.id,
-+        current_event_datetime=event_dt.isoformat(),
-+        timezone=TIMEZONE,
-+    )
-+
-+    context.user_data.pop("new_event_data", None)
-+    ensure_scheduler_started()
-+    schedule_all_reminders(context.application)
-+
-+    sheet_link = database.get_sheet_link(worksheet.title, worksheet.id)
-+    await update.message.reply_text(
-+        "–ù–æ–≤–æ–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ —Å–æ–∑–¥–∞–Ω–æ ‚úÖ\n"
-+        f"–õ–∏—Å—Ç —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤: {sheet_link}",
-+        disable_web_page_preview=True,
-+        reply_markup=MENU_KEYBOARD,
-+    )
-+    await _send_event_card(update, settings)
-+    return ConversationHandler.END
-+
-+
-+async def new_event_payment(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-+    if not await _ensure_admin(update):
-+        return ConversationHandler.END
-+    text = update.message.text or ""
-+    data = context.user_data.setdefault("new_event_data", {})
-+    if _is_cancel(text):
-+        await update.message.reply_text("–°–æ–∑–¥–∞–Ω–∏–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è –æ—Ç–º–µ–Ω–µ–Ω–æ.", reply_markup=MENU_KEYBOARD)
-+        context.user_data.pop("new_event_data", None)
-+        return ConversationHandler.END
-+    if _is_skip(text) or _is_clear(text):
-+        data["payment_link"] = ""
-+    else:
-+        link = text.strip()
-+        if not _is_valid_url(link):
-+            await update.message.reply_text(
-+                "–£–∫–∞–∂–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—É—é —Å—Å—ã–ª–∫—É (http/https) –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—ã –û—Ç–º–µ–Ω–∞/–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å."
-+            )
-+            return STATE_NEW_EVENT_PAYMENT
-+        data["payment_link"] = link
-+    return await _finalize_new_event(update, context)
-+
-+
- def build_admin_conversation() -> ConversationHandler:
-     return ConversationHandler(
-         entry_points=[
-             CommandHandler("admin", admin_command_entry),
-             CommandHandler("set_topic", set_topic_start),
-             CommandHandler("set_date", set_date_start),
-             CommandHandler("set_zoom", set_zoom_start),
-             CommandHandler("set_payment", set_payment_start),
-             CommandHandler("export", export_participants),
-             CommandHandler("notify", notify_start),
-             CommandHandler("current_event", show_current_event),
--            MessageHandler(filters.Regex("^‚úèÔ∏è"), set_topic_start),
--            MessageHandler(filters.Regex("^üìù –ò–∑–º–µ–Ω–∏—Ç—å –æ–ø–∏—Å–∞–Ω–∏–µ$"), set_description_start),
--            MessageHandler(filters.Regex("^üìÜ"), set_date_start),
--            MessageHandler(filters.Regex("^üîó"), set_zoom_start),
--            MessageHandler(filters.Regex("^üí≥"), set_payment_start),
--            MessageHandler(filters.Regex("^üì•"), export_participants),
--            MessageHandler(filters.Regex("^üì¢"), notify_start),
--            MessageHandler(filters.Regex("^üóì"), show_current_event),
-+            CommandHandler("new_event", start_new_event_flow),
-+            MessageHandler(filters.Regex(f"^{re.escape(BUTTON_SET_TOPIC)}$"), set_topic_start),
-+            MessageHandler(filters.Regex(f"^{re.escape(BUTTON_SET_DESCRIPTION)}$"), set_description_start),
-+            MessageHandler(filters.Regex(f"^{re.escape(BUTTON_SET_DATE)}$"), set_date_start),
-+            MessageHandler(filters.Regex(f"^{re.escape(BUTTON_SET_ZOOM)}$"), set_zoom_start),
-+            MessageHandler(filters.Regex(f"^{re.escape(BUTTON_SET_PAYMENT)}$"), set_payment_start),
-+            MessageHandler(filters.Regex(f"^{re.escape(BUTTON_EXPORT)}$"), export_participants),
-+            MessageHandler(filters.Regex(f"^{re.escape(BUTTON_NOTIFY)}$"), notify_start),
-+            MessageHandler(filters.Regex(f"^{re.escape(BUTTON_SHOW_EVENT)}$"), show_current_event),
-+            MessageHandler(filters.Regex(f"^{re.escape(BUTTON_NEW_EVENT)}$"), start_new_event_flow),
-         ],
-         states={
-             STATE_TOPIC: [MessageHandler(filters.TEXT & ~filters.COMMAND, set_topic_finish)],
-+            STATE_DESCRIPTION: [
-+                MessageHandler(filters.TEXT & ~filters.COMMAND, set_description_finish)
-+            ],
-             STATE_DATE: [MessageHandler(filters.TEXT & ~filters.COMMAND, set_date_finish)],
-             STATE_ZOOM: [MessageHandler(filters.TEXT & ~filters.COMMAND, set_zoom_finish)],
-             STATE_PAYMENT: [MessageHandler(filters.TEXT & ~filters.COMMAND, set_payment_finish)],
-             STATE_NOTIFY: [MessageHandler(filters.TEXT & ~filters.COMMAND, notify_finish)],
--            STATE_DESCRIPTION: [MessageHandler(filters.TEXT & ~filters.COMMAND, set_description_finish)],
-+            STATE_DECIDE_NEW_EVENT: [
-+                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_new_event_decision)
-+            ],
-+            STATE_NEW_EVENT_TITLE: [
-+                MessageHandler(filters.TEXT & ~filters.COMMAND, new_event_title)
-+            ],
-+            STATE_NEW_EVENT_DESCRIPTION: [
-+                MessageHandler(filters.TEXT & ~filters.COMMAND, new_event_description)
-+            ],
-+            STATE_NEW_EVENT_DATETIME: [
-+                MessageHandler(filters.TEXT & ~filters.COMMAND, new_event_datetime)
-+            ],
-+            STATE_NEW_EVENT_ZOOM: [
-+                MessageHandler(filters.TEXT & ~filters.COMMAND, new_event_zoom)
-+            ],
-+            STATE_NEW_EVENT_PAYMENT: [
-+                MessageHandler(filters.TEXT & ~filters.COMMAND, new_event_payment)
-+            ],
-         },
-         fallbacks=[CommandHandler("cancel", admin_command_entry)],
-         allow_reentry=True,
-     )
-+
-diff --git a/config.py b/config.py
-index 07e9bf3349e40d24c4350993de4641ad9bc99333..787e3634820c56eac2660098d72df003cb75a797 100644
---- a/config.py
-+++ b/config.py
-@@ -9,53 +9,57 @@ from typing import Any, Dict, Optional, Tuple
- BOT_TOKEN: str = "8439661494:AAG5nqW5raGjVjocSX6L8oCS1hZngqdq-Uo"
- 
- # Administrators who can access privileged commands.
- ADMINS: Tuple[Dict[str, Any], ...] = (
-     {
-         "chat_id": 7740254761,
-         "username": "z_ivan89",
-     },
- )
- 
- 
- # === Google Sheets Integration ===
- GSPREAD_CREDENTIALS_PATH = "./service_account.json"
- GSPREAD_SHEET_ID = "1f5bRTFlKQ3FD-u0cggKj-87HdXNzMwz_H8imefFaNmI"
- TIMEZONE = "Europe/Moscow"
- 
- 
- 
- # Storage locations
- DATA_DIR = Path("data")
- SETTINGS_FILE = DATA_DIR / "config.json"
- 
- _DEFAULT_SETTINGS: Dict[str, Any] = {
-     "topic": "–ü—Å–∏—Ö–æ–ª–æ–≥–∏—á–µ—Å–∫–∏–π –≤–µ–±–∏–Ω–∞—Ä",
-     "description": "–ê–≤—Ç–æ—Ä—Å–∫–∏–π –≤–µ–±–∏–Ω–∞—Ä –ø–æ –ø—Å–∏—Ö–æ–ª–æ–≥–∏–∏",
--    "event_datetime": None,  # ISO formatted date time string
-+    "current_event_id": None,
-+    "current_event_sheet_name": None,
-+    "current_event_sheet_gid": None,
-+    "current_event_datetime": None,  # ISO formatted date time string in TIMEZONE
-     "zoom_link": "",
-     "payment_link": "",
-+    "timezone": TIMEZONE,
- }
- 
- 
- def is_admin(chat_id: Optional[int] = None, username: Optional[str] = None) -> bool:
-     """Return True if provided identifiers match a known administrator."""
- 
-     normalized_username = (username or "").lstrip("@").lower()
-     for admin in ADMINS:
-         admin_chat_id = admin.get("chat_id")
-         admin_username = (admin.get("username") or "").lstrip("@").lower()
- 
-         if chat_id is not None and admin_chat_id == chat_id:
-             return True
-         if normalized_username and admin_username and normalized_username == admin_username:
-             return True
-     return False
- 
- 
- def ensure_data_dir() -> None:
-     """Ensure that all required folders exist."""
-     DATA_DIR.mkdir(parents=True, exist_ok=True)
- 
- 
- def load_settings() -> Dict[str, Any]:
-     """Load the admin editable settings from disk."""
-diff --git a/database.py b/database.py
-index f8d3b37f2bcb569794b0bbfd13d23616dcc5a219..e09be64cbea423fb9b01f64573b0ca90c65a6fb2 100644
---- a/database.py
-+++ b/database.py
-@@ -1,120 +1,239 @@
--"""Simple Excel backed storage for webinar participants."""
-+"""Google Sheets backed storage for webinar participants."""
- from __future__ import annotations
- 
- from dataclasses import dataclass
-+from datetime import datetime
- from pathlib import Path
- from typing import List, Optional
- 
-+import gspread
- import pandas as pd
--
--from config import DATA_DIR
--
--DATABASE_PATH = DATA_DIR / "participants.xlsx"
--COLUMNS = [
--    "–ò–º—è",
--    "Username",
--    "ChatID",
--    "Email",
--    "–§–æ—Ä–º–∞—Ç",
--    "–û–ø–ª–∞—Ç–∞",
--    "–§–∏–¥–±—ç–∫",
-+from google.oauth2.service_account import Credentials
-+from zoneinfo import ZoneInfo
-+
-+from config import (
-+    DATA_DIR,
-+    GSPREAD_CREDENTIALS_PATH,
-+    GSPREAD_SHEET_ID,
-+    TIMEZONE,
-+    load_settings,
-+)
-+
-+
-+SCOPES = (
-+    "https://www.googleapis.com/auth/spreadsheets",
-+    "https://www.googleapis.com/auth/drive.file",
-+)
-+
-+HEADERS = [
-+    "timestamp",
-+    "chat_id",
-+    "username",
-+    "name",
-+    "email",
-+    "role",
-+    "paid",
-+    "feedback",
- ]
- 
-+TZ = ZoneInfo(TIMEZONE)
-+
-+_client: gspread.Client | None = None
-+
- 
- @dataclass
- class Participant:
-     name: str
-     username: str
-     chat_id: int
-     email: str
--    participation_type: str = "free"
--    payment_status: str = "–Ω–µ—Ç"
-+    role: str = "free"
-+    paid: str = "no"
-     feedback: str = ""
- 
- 
--def _load_dataframe() -> pd.DataFrame:
--    if not DATABASE_PATH.exists():
--        ensure_database()
--    return pd.read_excel(DATABASE_PATH)
-+def _get_client() -> gspread.Client:
-+    global _client
-+    if _client is None:
-+        credentials = Credentials.from_service_account_file(
-+            GSPREAD_CREDENTIALS_PATH, scopes=SCOPES
-+        )
-+        _client = gspread.authorize(credentials)
-+    return _client
-+
- 
-+def _open_spreadsheet() -> gspread.Spreadsheet:
-+    client = _get_client()
-+    return client.open_by_key(GSPREAD_SHEET_ID)
- 
--def ensure_database() -> None:
--    """Create an empty database file if missing."""
--    DATA_DIR.mkdir(parents=True, exist_ok=True)
--    if DATABASE_PATH.exists():
-+
-+def _ensure_headers(worksheet: gspread.Worksheet) -> None:
-+    current_headers = worksheet.row_values(1)
-+    if [h.strip() for h in current_headers] == HEADERS:
-         return
--    empty = pd.DataFrame(columns=COLUMNS)
--    empty.to_excel(DATABASE_PATH, index=False)
--
--
--def add_or_update_participant(participant: Participant) -> None:
--    df = _load_dataframe()
--    mask = df["ChatID"] == participant.chat_id
--    if mask.any():
--        df.loc[mask, ["–ò–º—è", "Username", "Email"]] = [
--            participant.name,
--            participant.username,
--            participant.email,
--        ]
-+    worksheet.update("1:1", [HEADERS])
-+
-+
-+def create_event_sheet(sheet_name: str) -> gspread.Worksheet:
-+    spreadsheet = _open_spreadsheet()
-+    try:
-+        worksheet = spreadsheet.worksheet(sheet_name)
-+    except gspread.exceptions.WorksheetNotFound:
-+        worksheet = spreadsheet.add_worksheet(title=sheet_name, rows=100, cols=len(HEADERS))
-+        worksheet.update("1:1", [HEADERS])
-     else:
--        df = pd.concat(
-+        _ensure_headers(worksheet)
-+    return worksheet
-+
-+
-+def get_sheet_by_name(sheet_name: str) -> Optional[gspread.Worksheet]:
-+    spreadsheet = _open_spreadsheet()
-+    try:
-+        worksheet = spreadsheet.worksheet(sheet_name)
-+    except gspread.exceptions.WorksheetNotFound:
-+        return None
-+    _ensure_headers(worksheet)
-+    return worksheet
-+
-+
-+def get_current_worksheet() -> gspread.Worksheet:
-+    settings = load_settings()
-+    sheet_name = settings.get("current_event_sheet_name")
-+    if not sheet_name:
-+        raise RuntimeError("–ê–∫—Ç–∏–≤–Ω—ã–π –ª–∏—Å—Ç —Å–æ–±—ã—Ç–∏—è –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω")
-+    worksheet = get_sheet_by_name(sheet_name)
-+    if worksheet is None:
-+        worksheet = create_event_sheet(sheet_name)
-+    return worksheet
-+
-+
-+def _now_timestamp() -> str:
-+    return datetime.now(TZ).isoformat()
-+
-+
-+def _find_row_by_chat_id(worksheet: gspread.Worksheet, chat_id: int) -> Optional[int]:
-+    chat_id_str = str(chat_id)
-+    values = worksheet.col_values(2)
-+    for idx, value in enumerate(values, start=1):
-+        if value.strip() == chat_id_str:
-+            return idx
-+    return None
-+
-+
-+def _normalize_username(username: str) -> str:
-+    username = username.strip()
-+    if username and not username.startswith("@"):
-+        return f"@{username}"
-+    return username
-+
-+
-+def register_participant(participant: Participant) -> None:
-+    worksheet = get_current_worksheet()
-+    row_idx = _find_row_by_chat_id(worksheet, participant.chat_id)
-+    timestamp = _now_timestamp()
-+    username = _normalize_username(participant.username)
-+    if row_idx:
-+        existing = worksheet.row_values(row_idx)
-+        role = existing[5] if len(existing) > 5 else participant.role
-+        paid = existing[6] if len(existing) > 6 else participant.paid
-+        feedback = existing[7] if len(existing) > 7 else participant.feedback
-+        worksheet.update(
-+            f"A{row_idx}:H{row_idx}",
-             [
--                df,
--                pd.DataFrame(
--                    [
--                        [
--                            participant.name,
--                            participant.username,
--                            participant.chat_id,
--                            participant.email,
--                            participant.participation_type,
--                            participant.payment_status,
--                            participant.feedback,
--                        ]
--                    ],
--                    columns=COLUMNS,
--                ),
-+                [
-+                    timestamp,
-+                    str(participant.chat_id),
-+                    username,
-+                    participant.name,
-+                    participant.email,
-+                    role or participant.role,
-+                    paid or participant.paid,
-+                    feedback or participant.feedback,
-+                ]
-             ],
--            ignore_index=True,
-         )
--    df.to_excel(DATABASE_PATH, index=False)
-+    else:
-+        worksheet.append_row(
-+            [
-+                timestamp,
-+                str(participant.chat_id),
-+                username,
-+                participant.name,
-+                participant.email,
-+                participant.role,
-+                participant.paid,
-+                participant.feedback,
-+            ]
-+        )
- 
- 
--def update_participation(chat_id: int, participation_type: str, payment_status: str) -> None:
--    df = _load_dataframe()
--    mask = df["ChatID"] == chat_id
--    if not mask.any():
-+def update_participation(chat_id: int, role: str, paid: str) -> None:
-+    worksheet = get_current_worksheet()
-+    row_idx = _find_row_by_chat_id(worksheet, chat_id)
-+    if not row_idx:
-         return
--    df.loc[mask, ["–§–æ—Ä–º–∞—Ç", "–û–ø–ª–∞—Ç–∞"]] = [participation_type, payment_status]
--    df.to_excel(DATABASE_PATH, index=False)
-+    worksheet.update(f"F{row_idx}:G{row_idx}", [[role, paid]])
- 
- 
- def update_feedback(chat_id: int, feedback: str) -> None:
--    df = _load_dataframe()
--    mask = df["ChatID"] == chat_id
--    if not mask.any():
-+    worksheet = get_current_worksheet()
-+    row_idx = _find_row_by_chat_id(worksheet, chat_id)
-+    if not row_idx:
-         return
--    df.loc[mask, "–§–∏–¥–±—ç–∫"] = feedback
--    df.to_excel(DATABASE_PATH, index=False)
-+    worksheet.update(f"H{row_idx}", feedback)
- 
- 
--def get_participants() -> pd.DataFrame:
--    return _load_dataframe()
-+def get_participants(sheet_name: Optional[str] = None) -> pd.DataFrame:
-+    worksheet = get_current_worksheet() if sheet_name is None else get_or_create_sheet(sheet_name)
-+    records = worksheet.get_all_records()
-+    if not records:
-+        return pd.DataFrame(columns=HEADERS)
-+    return pd.DataFrame(records, columns=HEADERS)
- 
- 
- def list_chat_ids() -> List[int]:
--    df = _load_dataframe()
--    return [int(cid) for cid in df["ChatID"].dropna().tolist()]
-+    worksheet = get_current_worksheet()
-+    values = worksheet.col_values(2)
-+    chat_ids: List[int] = []
-+    for value in values[1:]:  # skip header
-+        value = value.strip()
-+        if not value:
-+            continue
-+        try:
-+            chat_ids.append(int(float(value)))
-+        except ValueError:
-+            continue
-+    return chat_ids
- 
- 
- def export_database(destination: Optional[Path] = None) -> Path:
--    """Create a copy of the database and return the file path."""
--    ensure_database()
-+    """Create an XLSX export of the current participant list."""
-+    df = get_participants()
-     if destination is None:
--        destination = DATABASE_PATH
--    else:
--        destination.parent.mkdir(parents=True, exist_ok=True)
--        df = _load_dataframe()
--        df.to_excel(destination, index=False)
--        return destination
-+        destination = DATA_DIR / "participants.xlsx"
-+    destination.parent.mkdir(parents=True, exist_ok=True)
-+    df.to_excel(destination, index=False)
-     return destination
-+
-+
-+def get_sheet_link(sheet_name: Optional[str] = None, gid: Optional[int] = None) -> str:
-+    if sheet_name is None:
-+        settings = load_settings()
-+        sheet_name = settings.get("current_event_sheet_name")
-+        gid = settings.get("current_event_sheet_gid")
-+    if not sheet_name:
-+        raise RuntimeError("–ê–∫—Ç–∏–≤–Ω—ã–π –ª–∏—Å—Ç —Å–æ–±—ã—Ç–∏—è –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω")
-+    if gid is None:
-+        worksheet = get_sheet_by_name(sheet_name)
-+        if worksheet is None:
-+            worksheet = create_event_sheet(sheet_name)
-+        gid = worksheet.id
-+    return f"https://docs.google.com/spreadsheets/d/{GSPREAD_SHEET_ID}/edit#gid={gid}"
-+
-+
-+def get_or_create_sheet(sheet_name: str) -> gspread.Worksheet:
-+    worksheet = get_sheet_by_name(sheet_name)
-+    if worksheet is None:
-+        worksheet = create_event_sheet(sheet_name)
-+    return worksheet
-+
-diff --git a/handlers.py b/handlers.py
-index d2b58dea74e4d5a5425e6ca6c746e8414ae3fbd3..1494baa334701b2125db8ef760f1542d0ab040d2 100644
---- a/handlers.py
-+++ b/handlers.py
-@@ -24,81 +24,88 @@ EMAIL_REGEX = re.compile(r"^[^@\s]+@[^@\s]+\.[^@\s]+$")
- 
- async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-     user = update.effective_user
-     if user and is_admin(chat_id=user.id, username=user.username):
-         from admin_panel import send_admin_panel
- 
-         await send_admin_panel(update, context)
-         return ConversationHandler.END
- 
-     await update.message.reply_text(
-         "–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –Ω–∞ –≤–µ–±–∏–Ω–∞—Ä –ø–æ –ø—Å–∏—Ö–æ–ª–æ–≥–∏–∏!\n"
-         "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ –≤–∞—à e-mail –¥–ª—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏.",
-         reply_markup=ReplyKeyboardRemove(),
-     )
-     return WAITING_EMAIL
- 
- 
- async def handle_email(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-     email = (update.message.text or "").strip()
-     if not EMAIL_REGEX.match(email):
-         await update.message.reply_text("–ü–æ—Ö–æ–∂–µ, —ç—Ç–æ –Ω–µ e-mail. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")
-         return WAITING_EMAIL
- 
-     user = update.effective_user
-     participant = database.Participant(
--        name=user.full_name,
--        username=f"@{user.username}" if user.username else "",
-+        name=(user.full_name or "") if user else "",
-+        username=f"@{user.username}" if user and user.username else "",
-         chat_id=update.effective_chat.id,
-         email=email,
-     )
--    database.add_or_update_participant(participant)
-+    try:
-+        database.register_participant(participant)
-+    except RuntimeError:
-+        await update.message.reply_text(
-+            "–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.",
-+            reply_markup=ReplyKeyboardRemove(),
-+        )
-+        return ConversationHandler.END
- 
-     await update.message.reply_text(
-         "–í—ã –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã –Ω–∞ –≤–µ–±–∏–Ω–∞—Ä üí´ –°—Å—ã–ª–∫–∞ –ø—Ä–∏–¥—ë—Ç –≤ –¥–µ–Ω—å –ø—Ä–æ–≤–µ–¥–µ–Ω–∏—è.",
-     )
- 
-     keyboard = ReplyKeyboardMarkup([[FREE_BUTTON], [PAID_BUTTON]], resize_keyboard=True)
-     await update.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ —Ñ–æ—Ä–º–∞—Ç —É—á–∞—Å—Ç–∏—è:", reply_markup=keyboard)
-     return WAITING_FORMAT
- 
- 
- async def handle_format(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-     choice = (update.message.text or "").strip()
-     settings = load_settings()
-     payment_link = settings.get("payment_link", "")
- 
-     if choice == FREE_BUTTON:
--        database.update_participation(update.effective_chat.id, "free", "–Ω–µ—Ç")
-+        database.update_participation(update.effective_chat.id, "free", "no")
-         await update.message.reply_text(
-             "–í—ã –≤—ã–±—Ä–∞–ª–∏ —Ñ–æ—Ä–º–∞—Ç –Ω–∞–±–ª—é–¥–∞—Ç–µ–ª—è. –ñ–¥–∏—Ç–µ —Å—Å—ã–ª–∫—É –≤ –¥–µ–Ω—å –≤–µ–±–∏–Ω–∞—Ä–∞!",
-             reply_markup=ReplyKeyboardRemove(),
-         )
-         return ConversationHandler.END
- 
-     if choice == PAID_BUTTON:
--        database.update_participation(update.effective_chat.id, "paid", "–æ–∂–∏–¥–∞–µ—Ç –æ–ø–ª–∞—Ç—ã")
-+        database.update_participation(update.effective_chat.id, "paid", "no")
-         if payment_link:
-             message = f"–î–ª—è –æ–ø–ª–∞—Ç—ã –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Å—Å—ã–ª–∫—É: {payment_link}"
-         else:
-             message = "–°—Å—ã–ª–∫–∞ –¥–ª—è –æ–ø–ª–∞—Ç—ã –ø–æ–∫–∞ –Ω–µ –∑–∞–¥–∞–Ω–∞. –°–≤—è–∂–∏—Ç–µ—Å—å —Å –æ—Ä–≥–∞–Ω–∏–∑–∞—Ç–æ—Ä–æ–º."
-         await update.message.reply_text(message, reply_markup=ReplyKeyboardRemove())
-         return ConversationHandler.END
- 
-     await update.message.reply_text(
-         "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –¥–ª—è –≤—ã–±–æ—Ä–∞ —Ñ–æ—Ä–º–∞—Ç–∞ —É—á–∞—Å—Ç–∏—è."
-     )
-     return WAITING_FORMAT
- 
- 
- async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-     await update.message.reply_text(
-         "–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞.", reply_markup=ReplyKeyboardRemove()
-     )
-     return ConversationHandler.END
- 
- 
- async def feedback_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
-     chat_id = update.effective_chat.id
-     awaiting = context.application.bot_data.setdefault("awaiting_feedback", set())
-     if chat_id not in awaiting:
-         return
-diff --git a/main.py b/main.py
-index 2df2ff35363658fc1948be94b4f8460f2f415b76..2dab7fa78f4974bc7d849b94202d0a8e1b9eb869 100644
---- a/main.py
-+++ b/main.py
-@@ -1,32 +1,31 @@
- """Entry point for the psychology webinar Telegram bot."""
- from __future__ import annotations
- 
- from telegram.ext import Application, MessageHandler, filters
- 
- import config
- import database
- from admin_panel import build_admin_conversation
- from handlers import build_conversation_handler, feedback_handler
- from scheduler import ensure_scheduler_started, schedule_all_reminders
- 
- 
- async def _post_init(application: Application) -> None:
-     config.ensure_data_dir()
--    database.ensure_database()
-     ensure_scheduler_started()
-     schedule_all_reminders(application)
- 
- 
- def main() -> None:
-     application = Application.builder().token(config.BOT_TOKEN).build()
-     application.post_init = _post_init
- 
-     application.add_handler(build_conversation_handler())
-     application.add_handler(build_admin_conversation())
-     application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, feedback_handler))
- 
-     application.run_polling()
- 
- 
- if __name__ == "__main__":
-     main()
-diff --git a/requirements.txt b/requirements.txt
-index 7c0ab9b670cd6f641f4afae5946b6577c1f9aaef..fdaa8dd647a6ea3ae1614ef57891ffca22a1ba54 100644
---- a/requirements.txt
-+++ b/requirements.txt
-@@ -1,4 +1,7 @@
- python-telegram-bot==20.7
- apscheduler==3.10.4
- pandas==2.2.2
- openpyxl==3.1.2
-+gspread==6.1.2
-+google-auth==2.30.0
-+Unidecode==1.3.8
-diff --git a/scheduler.py b/scheduler.py
-index b3f944967b0af87da19b16f1916edd8d5ee8e7ca..07281808c27c514123e675b765d8518e17a8bf67 100644
---- a/scheduler.py
-+++ b/scheduler.py
-@@ -1,67 +1,105 @@
--"""Apscheduler integration for webinar reminders."""
-+"""Apscheduler integration for webinar reminders bound to Google Sheets events."""
- from __future__ import annotations
- 
- from datetime import datetime, timedelta
-+from zoneinfo import ZoneInfo
- 
- from apscheduler.schedulers.asyncio import AsyncIOScheduler
- from apscheduler.triggers.date import DateTrigger
- 
- import database
--from config import load_settings
-+from config import TIMEZONE, load_settings
- 
--scheduler = AsyncIOScheduler(timezone="Europe/Moscow")
-+scheduler = AsyncIOScheduler(timezone=ZoneInfo(TIMEZONE))
- 
- 
- async def _send_bulk_message(application, text: str) -> None:
-     participants = database.get_participants()
-     for _, row in participants.iterrows():
--        chat_id = int(row["ChatID"])
-+        chat_id = row.get("chat_id")
-         if not chat_id:
-             continue
--        await application.bot.send_message(chat_id=chat_id, text=text)
-+        try:
-+            chat_id_int = int(chat_id)
-+        except (TypeError, ValueError):
-+            continue
-+        await application.bot.send_message(chat_id=chat_id_int, text=text)
- 
- 
- async def _send_feedback_request(application, text: str) -> None:
-     participants = database.get_participants()
-     waiting_feedback = application.bot_data.setdefault("awaiting_feedback", set())
-     for _, row in participants.iterrows():
--        chat_id = int(row["ChatID"])
-+        chat_id = row.get("chat_id")
-         if not chat_id:
-             continue
--        waiting_feedback.add(chat_id)
--        await application.bot.send_message(chat_id=chat_id, text=text)
-+        try:
-+            chat_id_int = int(chat_id)
-+        except (TypeError, ValueError):
-+            continue
-+        waiting_feedback.add(chat_id_int)
-+        await application.bot.send_message(chat_id=chat_id_int, text=text)
-+
- 
-+def _clear_event_jobs(event_id: str) -> None:
-+    for job in scheduler.get_jobs():
-+        if job.id and job.id.startswith(f"{event_id}::"):
-+            scheduler.remove_job(job.id)
- 
--def _schedule_job(run_time: datetime, coroutine, *args) -> None:
-+
-+def _schedule_job(job_id: str, run_time: datetime, coroutine, *args) -> None:
-     if run_time <= datetime.now(run_time.tzinfo):
-         return
--    scheduler.add_job(coroutine, trigger=DateTrigger(run_date=run_time), args=args, misfire_grace_time=300)
-+    scheduler.add_job(
-+        coroutine,
-+        trigger=DateTrigger(run_date=run_time),
-+        args=args,
-+        id=job_id,
-+        replace_existing=True,
-+        misfire_grace_time=300,
-+    )
- 
- 
- def schedule_all_reminders(application) -> None:
-     settings = load_settings()
--    event_iso = settings.get("event_datetime")
--    if not event_iso:
-+    event_iso = settings.get("current_event_datetime")
-+    event_id = settings.get("current_event_id")
-+    if not event_iso or not event_id:
-+        scheduler.remove_all_jobs()
-         return
- 
-     event_dt = datetime.fromisoformat(event_iso)
--    scheduler.remove_all_jobs()
-+    _clear_event_jobs(event_id)
- 
-     zoom_link = settings.get("zoom_link", "")
- 
-     day_before = event_dt - timedelta(days=1)
-     hour_before = event_dt - timedelta(hours=1)
-     day_after = event_dt + timedelta(days=1)
- 
--    text_day_before = "–ù–∞–ø–æ–º–∏–Ω–∞–µ–º, –≤–µ–±–∏–Ω–∞—Ä —É–∂–µ –∑–∞–≤—Ç—Ä–∞! üí´\n" + (f"–í–∞—à–∞ —Å—Å—ã–ª–∫–∞: {zoom_link}" if zoom_link else "")
--    text_hour_before = "–°–∫–æ—Ä–æ –Ω–∞—á–∏–Ω–∞–µ–º! –í–æ—Ç –≤–∞—à–∞ —Å—Å—ã–ª–∫–∞: {link}".format(link=zoom_link or "–°—Å—ã–ª–∫–∞ –ø–æ—è–≤–∏—Ç—Å—è –ø–æ–∑–∂–µ")
-+    text_day_before = "–ù–∞–ø–æ–º–∏–Ω–∞–µ–º, –≤–µ–±–∏–Ω–∞—Ä —É–∂–µ –∑–∞–≤—Ç—Ä–∞! üí´"
-+    if zoom_link:
-+        text_day_before += f"\n–í–∞—à–∞ —Å—Å—ã–ª–∫–∞: {zoom_link}"
-+
-+    text_hour_before = "–°–∫–æ—Ä–æ –Ω–∞—á–∏–Ω–∞–µ–º!"
-+    if zoom_link:
-+        text_hour_before += f" –í–æ—Ç –≤–∞—à–∞ —Å—Å—ã–ª–∫–∞: {zoom_link}"
-+    else:
-+        text_hour_before += " –°—Å—ã–ª–∫–∞ –ø–æ—è–≤–∏—Ç—Å—è –ø–æ–∑–∂–µ."
-+
-     text_day_after = "–°–ø–∞—Å–∏–±–æ, —á—Ç–æ –±—ã–ª–∏ —Å –Ω–∞–º–∏ üíï –ü–æ–¥–µ–ª–∏—Ç–µ—Å—å –≤–ø–µ—á–∞—Ç–ª–µ–Ω–∏—è–º–∏?"
- 
--    _schedule_job(day_before, _send_bulk_message, application, text_day_before)
--    _schedule_job(hour_before, _send_bulk_message, application, text_hour_before)
--    _schedule_job(day_after, _send_feedback_request, application, text_day_after)
-+    _schedule_job(f"{event_id}::day_before", day_before, _send_bulk_message, application, text_day_before)
-+    _schedule_job(f"{event_id}::hour_before", hour_before, _send_bulk_message, application, text_hour_before)
-+    _schedule_job(
-+        f"{event_id}::feedback",
-+        day_after,
-+        _send_feedback_request,
-+        application,
-+        text_day_after,
-+    )
- 
- 
- def ensure_scheduler_started() -> None:
-     if not scheduler.running:
-         scheduler.start()
-
diff --git a/admin_panel.py b/admin_panel.py
index d1bcf7f2e8227fe97f21aae77e903bcabb1c1f81..79529c3c634921e36c2a79f2baa0f28e7513aa76 100644
--- a/admin_panel.py
+++ b/admin_panel.py
@@ -1,734 +1,501 @@
-"""Administrative tools for configuring the webinar bot with Google Sheets storage."""
+"""Inline administrative tools for configuring the webinar bot."""
 from __future__ import annotations
 
 import html
 import re
 from datetime import datetime
 from typing import Dict, Optional
 from uuid import uuid4
 
-from telegram import ReplyKeyboardMarkup, ReplyKeyboardRemove, Update
+from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
 from telegram.constants import ParseMode
 from telegram.ext import (
+    CallbackQueryHandler,
     CommandHandler,
     ContextTypes,
     ConversationHandler,
     MessageHandler,
     filters,
 )
-
-from unidecode import unidecode
 from zoneinfo import ZoneInfo
 
 import database
 from config import TIMEZONE, is_admin, load_settings, update_settings
 from scheduler import ensure_scheduler_started, schedule_all_reminders
 
-BUTTON_SET_TOPIC = "‚úèÔ∏è –ò–∑–º–µ–Ω–∏—Ç—å –Ω–∞–∑–≤–∞–Ω–∏–µ"
-BUTTON_SET_DESCRIPTION = "üìù –ò–∑–º–µ–Ω–∏—Ç—å –æ–ø–∏—Å–∞–Ω–∏–µ"
-BUTTON_SET_DATE = "üìÜ –ò–∑–º–µ–Ω–∏—Ç—å –¥–∞—Ç—É"
-BUTTON_SET_ZOOM = "üîó –û–±–Ω–æ–≤–∏—Ç—å Zoom"
-BUTTON_SET_PAYMENT = "üí≥ –û–±–Ω–æ–≤–∏—Ç—å –æ–ø–ª–∞—Ç—É"
-BUTTON_EXPORT = "üì• –°–ø–∏—Å–æ–∫ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤"
-BUTTON_NOTIFY = "üì¢ –†–∞–∑–æ—Å–ª–∞—Ç—å –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ"
-BUTTON_SHOW_EVENT = "üëÅ –¢–µ–∫—É—â–µ–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ"
-BUTTON_NEW_EVENT = "üÜï –ù–æ–≤–æ–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ"
-BUTTON_CREATE_NEW_PROMPT = "üÜï –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤–æ–µ"
-BUTTON_CANCEL_ACTION = "–û—Ç–º–µ–Ω–∞"
-
-MENU_KEYBOARD = ReplyKeyboardMarkup(
-    [
-        [BUTTON_NEW_EVENT, BUTTON_SHOW_EVENT],
-        [BUTTON_SET_TOPIC, BUTTON_SET_DESCRIPTION],
-        [BUTTON_SET_DATE, BUTTON_SET_ZOOM],
-        [BUTTON_SET_PAYMENT, BUTTON_EXPORT],
-        [BUTTON_NOTIFY],
-    ],
-    resize_keyboard=True,
-)
+ADMIN_PANEL, WAITING_BROADCAST, WAITING_WELCOME, NEW_EVENT_TITLE, NEW_EVENT_DESCRIPTION, NEW_EVENT_DATETIME, NEW_EVENT_ZOOM, NEW_EVENT_PAYMENT = range(8)
 
-(
-    STATE_TOPIC,
-    STATE_DATE,
-    STATE_ZOOM,
-    STATE_PAYMENT,
-    STATE_NOTIFY,
-    STATE_DESCRIPTION,
-    STATE_DECIDE_NEW_EVENT,
-    STATE_NEW_EVENT_TITLE,
-    STATE_NEW_EVENT_DESCRIPTION,
-    STATE_NEW_EVENT_DATETIME,
-    STATE_NEW_EVENT_ZOOM,
-    STATE_NEW_EVENT_PAYMENT,
-) = range(12)
-
-CANCEL_TEXT = "–æ—Ç–º–µ–Ω–∞"
-CLEAR_TEXT = "–æ—á–∏—Å—Ç–∏—Ç—å"
-SKIP_TEXT = "–ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å"
-TOPIC_MAX_LENGTH = 200
-MAX_SLUG_LENGTH = 30
+CALLBACK_NEW_EVENT = "admin:new_event"
+CALLBACK_VIEW_REG = "admin:registrations"
+CALLBACK_BROADCAST = "admin:broadcast"
+CALLBACK_WELCOME = "admin:welcome"
+CALLBACK_OPEN_SHEET = "admin:sheet"
+CALLBACK_EXPORT_CSV = "admin:export"
+CALLBACK_REFRESH = "admin:refresh"
 
 TZ = ZoneInfo(TIMEZONE)
-MISSING_VALUE = "‚ùóÔ∏è–ù–µ —É–∫–∞–∑–∞–Ω–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º"
-
-
-def _normalize_command_text(text: Optional[str]) -> str:
-    return (text or "").strip().lower()
-
-
-def _is_cancel(text: Optional[str]) -> bool:
-    return _normalize_command_text(text) == CANCEL_TEXT
-
-
-def _is_clear(text: Optional[str]) -> bool:
-    return _normalize_command_text(text) == CLEAR_TEXT
-
-
-def _is_skip(text: Optional[str]) -> bool:
-    return _normalize_command_text(text) == SKIP_TEXT
-
-
-async def _ensure_admin(update: Update, *, message: str = "–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.") -> bool:
-    user = update.effective_user
-    if user and is_admin(chat_id=user.id, username=user.username):
-        return True
-    if update.message:
-        await update.message.reply_text(message)
-    else:
-        await update.effective_chat.send_message(message)
-    return False
-
-
-def _slugify_topic(topic: str) -> str:
-    normalized = unidecode(topic or "").lower()
-    normalized = re.sub(r"[\s./]+", "-", normalized)
-    normalized = re.sub(r"[^a-z0-9\-_]", "", normalized)
-    normalized = re.sub(r"-+", "-", normalized).strip("-")
-    if not normalized:
-        normalized = "event"
-    return normalized[:MAX_SLUG_LENGTH]
 
 
-def _generate_sheet_name(topic: str, event_dt: datetime) -> str:
-    base_slug = _slugify_topic(topic)
-    local_dt = event_dt.astimezone(TZ)
-    date_part = local_dt.strftime("%d-%m-%Y")
-    candidate = f"{date_part}__{base_slug}"
-    suffix = 1
-    while database.get_sheet_by_name(candidate) is not None:
-        suffix += 1
-        trimmed_slug = base_slug[: max(1, MAX_SLUG_LENGTH - len(f"-{suffix}"))]
-        candidate = f"{date_part}__{trimmed_slug}-{suffix}"
-    return candidate
+def _build_admin_keyboard() -> InlineKeyboardMarkup:
+    keyboard = [
+        [InlineKeyboardButton("üÜï –°–æ–∑–¥–∞—Ç—å –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ", callback_data=CALLBACK_NEW_EVENT)],
+        [InlineKeyboardButton("üìã –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏", callback_data=CALLBACK_VIEW_REG)],
+        [InlineKeyboardButton("üì¢ –ù–∞–ø–æ–º–Ω–∏—Ç—å –≤—Å–µ–º", callback_data=CALLBACK_BROADCAST)],
+        [InlineKeyboardButton("üëã –ü—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ", callback_data=CALLBACK_WELCOME)],
+        [InlineKeyboardButton("üìä Google Sheet", callback_data=CALLBACK_OPEN_SHEET)],
+        [InlineKeyboardButton("‚¨áÔ∏è –≠–∫—Å–ø–æ—Ä—Ç CSV", callback_data=CALLBACK_EXPORT_CSV)],
+        [InlineKeyboardButton("üîÑ –û–±–Ω–æ–≤–∏—Ç—å", callback_data=CALLBACK_REFRESH)],
+    ]
+    return InlineKeyboardMarkup(keyboard)
 
 
-def _generate_event_id() -> str:
-    return uuid4().hex[:12]
+def _format_value(value: Optional[object]) -> str:
+    if value is None:
+        return "‚ùóÔ∏è–ù–µ —É–∫–∞–∑–∞–Ω–æ"
+    if isinstance(value, str):
+        stripped = value.strip()
+        return stripped if stripped else "‚ùóÔ∏è–ù–µ —É–∫–∞–∑–∞–Ω–æ"
+    return str(value)
 
 
-def _parse_datetime(text: str) -> datetime:
-    text = (text or "").strip()
-    formats = ["%d.%m.%Y %H:%M", "%d.%m %H:%M", "%Y-%m-%d %H:%M"]
-    for fmt in formats:
-        try:
-            dt = datetime.strptime(text, fmt)
-            if fmt == "%d.%m %H:%M":
-                dt = dt.replace(year=datetime.now(TZ).year)
-            return dt.replace(tzinfo=TZ)
-        except ValueError:
-            continue
-    raise ValueError("invalid format")
+def _event_datetime(settings: Dict[str, object]) -> Optional[datetime]:
+    event_iso = settings.get("current_event_datetime")
+    if not event_iso:
+        return None
+    try:
+        return datetime.fromisoformat(str(event_iso))
+    except ValueError:
+        return None
 
 
 def _format_datetime(dt: Optional[datetime]) -> str:
     if not dt:
-        return MISSING_VALUE
+        return "‚ùóÔ∏è–ù–µ —É–∫–∞–∑–∞–Ω–æ"
     local_dt = dt.astimezone(TZ)
     month_names = [
         "",
         "—è–Ω–≤–∞—Ä—è",
         "—Ñ–µ–≤—Ä–∞–ª—è",
         "–º–∞—Ä—Ç–∞",
         "–∞–ø—Ä–µ–ª—è",
         "–º–∞—è",
         "–∏—é–Ω—è",
         "–∏—é–ª—è",
         "–∞–≤–≥—É—Å—Ç–∞",
         "—Å–µ–Ω—Ç—è–±—Ä—è",
         "–æ–∫—Ç—è–±—Ä—è",
         "–Ω–æ—è–±—Ä—è",
         "–¥–µ–∫–∞–±—Ä—è",
     ]
-    month_name = month_names[local_dt.month] if 1 <= local_dt.month <= 12 else local_dt.strftime("%B")
-    return f"{local_dt.day} {month_name} {local_dt.year}, {local_dt.strftime('%H:%M')}"
-
-
-def _event_datetime(settings: Dict[str, object]) -> Optional[datetime]:
-    event_iso = settings.get("current_event_datetime")
-    if not event_iso:
-        return None
-    try:
-        return datetime.fromisoformat(str(event_iso))
-    except ValueError:
-        return None
-
-
-def _event_has_started(settings: Dict[str, object]) -> bool:
-    dt = _event_datetime(settings)
-    if not dt:
-        return False
-    now = datetime.now(TZ)
-    return now >= dt
-
-
-def _format_value(value: Optional[object]) -> str:
-    if value is None:
-        return MISSING_VALUE
-    if isinstance(value, str):
-        stripped = value.strip()
-        return stripped if stripped else MISSING_VALUE
-    return str(value)
-
-
-def _build_event_card(settings: Dict[str, object]) -> str:
-    topic = _format_value(settings.get("topic"))
-    description = _format_value(settings.get("description"))
-    zoom_link = _format_value(settings.get("zoom_link"))
-    payment_link = _format_value(settings.get("payment_link"))
-
-    dt = _event_datetime(settings)
-    dt_text = _format_datetime(dt)
-
-    lines = ["<b>–¢–µ–∫—É—â–µ–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ</b>"]
-    lines.append(f"üéì –ù–∞–∑–≤–∞–Ω–∏–µ: {html.escape(topic)}")
-    lines.append(f"üìù –û–ø–∏—Å–∞–Ω–∏–µ: {html.escape(description)}")
-    lines.append(f"üìÖ –î–∞—Ç–∞ –∏ –≤—Ä–µ–º—è: {html.escape(dt_text)}")
-    lines.append(f"üîó Zoom: {html.escape(zoom_link)}")
-    lines.append(f"üí≥ –û–ø–ª–∞—Ç–∞: {html.escape(payment_link)}")
-    lines.append(f"üåç –ß–∞—Å–æ–≤–æ–π –ø–æ—è—Å: {html.escape(TIMEZONE)}")
+    month = month_names[local_dt.month] if 1 <= local_dt.month <= 12 else local_dt.strftime("%B")
+    return f"{local_dt.day} {month} {local_dt.year}, {local_dt.strftime('%H:%M')}"
+
+
+def _build_panel_text(settings: Dict[str, object], extra: Optional[str] = None) -> str:
+    topic = html.escape(_format_value(settings.get("topic")))
+    description = html.escape(_format_value(settings.get("description")))
+    welcome = html.escape(_format_value(settings.get("welcome_text")))
+    zoom_link = html.escape(settings.get("zoom_link") or "‚ùóÔ∏è–ù–µ —É–∫–∞–∑–∞–Ω–æ")
+    payment_link = html.escape(settings.get("payment_link") or "‚ùóÔ∏è–ù–µ —É–∫–∞–∑–∞–Ω–æ")
+    dt_text = html.escape(_format_datetime(_event_datetime(settings)))
+
+    lines = ["<b>–ü–∞–Ω–µ–ª—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞</b>"]
+    lines.append(f"üëã –ü—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ: {welcome}")
+    lines.append(f"üéì –ù–∞–∑–≤–∞–Ω–∏–µ: {topic}")
+    lines.append(f"üìù –û–ø–∏—Å–∞–Ω–∏–µ: {description}")
+    lines.append(f"üìÖ –î–∞—Ç–∞ –∏ –≤—Ä–µ–º—è: {dt_text}")
+    lines.append(f"üîó Zoom: {zoom_link}")
+    lines.append(f"üí≥ –û–ø–ª–∞—Ç–∞: {payment_link}")
 
     sheet_name = settings.get("current_event_sheet_name")
-    sheet_gid = settings.get("current_event_sheet_gid")
     if sheet_name:
-        try:
-            sheet_link = database.get_sheet_link(sheet_name, sheet_gid)
-            lines.append(f"üìä –£—á–∞—Å—Ç–Ω–∏–∫–∏: <a href=\"{sheet_link}\">–û—Ç–∫—Ä—ã—Ç—å –ª–∏—Å—Ç</a>")
-        except RuntimeError:
-            lines.append("üìä –£—á–∞—Å—Ç–Ω–∏–∫–∏: –ª–∏—Å—Ç –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω")
+        lines.append(f"üìä –ê–∫—Ç–∏–≤–Ω—ã–π –ª–∏—Å—Ç: {html.escape(sheet_name)}")
     else:
-        lines.append("üìä –£—á–∞—Å—Ç–Ω–∏–∫–∏: –ª–∏—Å—Ç –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω")
-
-    if _event_has_started(settings):
-        lines.append("\n‚ö†Ô∏è –ú–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ —É–∂–µ –Ω–∞—á–∞–ª–æ—Å—å. –ò–∑–º–µ–Ω–µ–Ω–∏—è –Ω–µ–≤–æ–∑–º–æ–∂–Ω—ã.")
-
+        lines.append("üìä –ê–∫—Ç–∏–≤–Ω—ã–π –ª–∏—Å—Ç: –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω")
+    if extra:
+        lines.append("")
+        lines.append(extra)
     return "\n".join(lines)
 
 
-async def _send_event_card(update: Update, settings: Optional[Dict[str, object]] = None) -> None:
-    if settings is None:
-        settings = load_settings()
-    text = _build_event_card(settings)
+async def _ensure_admin(update: Update) -> bool:
+    user = update.effective_user
+    if user and is_admin(chat_id=user.id, username=user.username):
+        return True
     if update.message:
-        await update.message.reply_text(
+        await update.message.reply_text("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤ –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∫–æ–º–∞–Ω–¥—ã.")
+    elif update.callback_query:
+        await update.callback_query.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤", show_alert=True)
+    return False
+
+
+async def show_admin_panel(
+    update: Update,
+    context: ContextTypes.DEFAULT_TYPE,
+    *,
+    status_message: Optional[str] = None,
+) -> None:
+    settings = load_settings()
+    text = _build_panel_text(settings, status_message)
+    keyboard = _build_admin_keyboard()
+    chat = update.effective_chat
+    chat_id = chat.id if chat else None
+    if update.callback_query and update.callback_query.message:
+        await update.callback_query.message.edit_text(
             text,
+            reply_markup=keyboard,
             parse_mode=ParseMode.HTML,
-            reply_markup=MENU_KEYBOARD,
             disable_web_page_preview=True,
         )
-    else:
-        await update.effective_chat.send_message(
-            text,
+        context.user_data["admin_panel_message_id"] = update.callback_query.message.message_id
+        return
+
+    message_id = context.user_data.get("admin_panel_message_id")
+    if chat_id and message_id:
+        try:
+            await context.bot.edit_message_text(
+                chat_id=chat_id,
+                message_id=message_id,
+                text=text,
+                reply_markup=keyboard,
+                parse_mode=ParseMode.HTML,
+                disable_web_page_preview=True,
+            )
+            return
+        except Exception:
+            pass
+
+    if chat_id:
+        sent = await context.bot.send_message(
+            chat_id=chat_id,
+            text=text,
+            reply_markup=keyboard,
             parse_mode=ParseMode.HTML,
-            reply_markup=MENU_KEYBOARD,
             disable_web_page_preview=True,
         )
-
-
-async def send_admin_panel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
-    await _send_event_card(update)
-
-
-async def _maybe_require_new_event(update: Update) -> Optional[Dict[str, object]]:
-    settings = load_settings()
-    if not settings.get("current_event_id") or not settings.get("current_event_sheet_name"):
-        await _prompt_new_event_creation(update, started=False)
-        return None
-    if _event_has_started(settings):
-        await _prompt_new_event_creation(update, started=True)
-        return None
-    return settings
-
-
-async def _prompt_new_event_creation(update: Update, *, started: bool) -> None:
-    keyboard = ReplyKeyboardMarkup(
-        [[BUTTON_CREATE_NEW_PROMPT], [BUTTON_CANCEL_ACTION]], resize_keyboard=True
-    )
-    if started:
-        message = (
-            "–¢–µ–∫—É—â–µ–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ —É–∂–µ –Ω–∞—á–∞–ª–æ—Å—å. –î–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏–π —Å–æ–∑–¥–∞–π—Ç–µ –Ω–æ–≤–æ–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ."
-        )
-    else:
-        message = "–ê–∫—Ç–∏–≤–Ω–æ–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–æ. –°–æ–∑–¥–∞–π—Ç–µ –Ω–æ–≤–æ–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ."
-    if update.message:
-        await update.message.reply_text(message, reply_markup=keyboard)
-    else:
-        await update.effective_chat.send_message(message, reply_markup=keyboard)
-
-
-async def show_current_event(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-    if not await _ensure_admin(update):
-        return ConversationHandler.END
-    await _send_event_card(update)
-    return ConversationHandler.END
+        context.user_data["admin_panel_message_id"] = sent.message_id
 
 
 async def admin_command_entry(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-    if not await _ensure_admin(update, message="–≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É."):
-        return ConversationHandler.END
-    await send_admin_panel(update, context)
-    return ConversationHandler.END
-
-
-async def set_topic_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
     if not await _ensure_admin(update):
         return ConversationHandler.END
-    settings = await _maybe_require_new_event(update)
-    if settings is None:
-        return STATE_DECIDE_NEW_EVENT
-    await update.message.reply_text(
-        "–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è (–¥–æ 200 —Å–∏–º–≤–æ–ª–æ–≤).\n–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã: –û—Ç–º–µ–Ω–∞.",
-        reply_markup=ReplyKeyboardRemove(),
-    )
-    return STATE_TOPIC
+    await show_admin_panel(update, context)
+    context.user_data.pop("new_event", None)
+    return ADMIN_PANEL
 
 
-async def set_topic_finish(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-    if not await _ensure_admin(update):
-        return ConversationHandler.END
-    text = (update.message.text or "").strip()
-    if _is_cancel(text):
-        await update.message.reply_text("–ò–∑–º–µ–Ω–µ–Ω–∏–µ –Ω–∞–∑–≤–∞–Ω–∏—è –æ—Ç–º–µ–Ω–µ–Ω–æ.", reply_markup=MENU_KEYBOARD)
-        return ConversationHandler.END
-    if not text:
-        await update.message.reply_text("–ù–∞–∑–≤–∞–Ω–∏–µ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")
-        return STATE_TOPIC
-    if len(text) > TOPIC_MAX_LENGTH:
-        await update.message.reply_text(
-            f"–ù–∞–∑–≤–∞–Ω–∏–µ —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω–æ–µ. –ú–∞–∫—Å–∏–º—É–º {TOPIC_MAX_LENGTH} —Å–∏–º–≤–æ–ª–æ–≤."
-        )
-        return STATE_TOPIC
-    settings = update_settings(topic=text)
-    await update.message.reply_text("‚úÖ –ù–∞–∑–≤–∞–Ω–∏–µ –æ–±–Ω–æ–≤–ª–µ–Ω–æ.", reply_markup=MENU_KEYBOARD)
-    await _send_event_card(update, settings)
-    return ConversationHandler.END
+def _slugify_topic(topic: str) -> str:
+    normalized = re.sub(r"[^\w\s-]", "", topic, flags=re.UNICODE)
+    normalized = normalized.strip().lower()
+    normalized = re.sub(r"[\s./]+", "-", normalized)
+    normalized = re.sub(r"-+", "-", normalized).strip("-")
+    return normalized or "event"
 
 
-async def set_description_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-    if not await _ensure_admin(update):
-        return ConversationHandler.END
-    settings = await _maybe_require_new_event(update)
-    if settings is None:
-        return STATE_DECIDE_NEW_EVENT
-    await update.message.reply_text(
-        "–û—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è.\n–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã: –û—Ç–º–µ–Ω–∞, –û—á–∏—Å—Ç–∏—Ç—å.",
-        reply_markup=ReplyKeyboardRemove(),
-    )
-    return STATE_DESCRIPTION
+def _generate_sheet_name(topic: str, event_dt: datetime) -> str:
+    base_slug = _slugify_topic(topic)
+    date_part = event_dt.astimezone(TZ).strftime("%d-%m-%Y")
+    candidate = f"{date_part}__{base_slug}"
+    suffix = 1
+    while database.get_sheet_by_name(candidate) is not None:
+        suffix += 1
+        candidate = f"{date_part}__{base_slug}-{suffix}"
+    return candidate[:30]
 
 
-async def set_description_finish(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-    if not await _ensure_admin(update):
-        return ConversationHandler.END
-    raw_text = update.message.text or ""
-    if _is_cancel(raw_text):
-        await update.message.reply_text("–ò–∑–º–µ–Ω–µ–Ω–∏–µ –æ–ø–∏—Å–∞–Ω–∏—è –æ—Ç–º–µ–Ω–µ–Ω–æ.", reply_markup=MENU_KEYBOARD)
-        return ConversationHandler.END
-    if _is_clear(raw_text):
-        settings = update_settings(description="")
-        await update.message.reply_text("–û–ø–∏—Å–∞–Ω–∏–µ –æ—á–∏—â–µ–Ω–æ.", reply_markup=MENU_KEYBOARD)
-        await _send_event_card(update, settings)
-        return ConversationHandler.END
-    stripped = raw_text.strip()
-    if not stripped:
-        await update.message.reply_text(
-            "–û–ø–∏—Å–∞–Ω–∏–µ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º. –í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –û—á–∏—Å—Ç–∏—Ç—å."
-        )
-        return STATE_DESCRIPTION
-    settings = update_settings(description=stripped)
-    await update.message.reply_text("‚úÖ –û–ø–∏—Å–∞–Ω–∏–µ –æ–±–Ω–æ–≤–ª–µ–Ω–æ.", reply_markup=MENU_KEYBOARD)
-    await _send_event_card(update, settings)
-    return ConversationHandler.END
+def _generate_event_id() -> str:
+    return uuid4().hex[:12]
 
 
-async def set_date_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-    if not await _ensure_admin(update):
-        return ConversationHandler.END
-    settings = await _maybe_require_new_event(update)
-    if settings is None:
-        return STATE_DECIDE_NEW_EVENT
-    await update.message.reply_text(
-        "–í–≤–µ–¥–∏—Ç–µ –¥–∞—Ç—É –∏ –≤—Ä–µ–º—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ –î–î.–ú–ú.–ì–ì–ì–ì –ß–ß:–ú–ú –∏–ª–∏ –î–î.–ú–ú –ß–ß:–ú–ú.",
-        reply_markup=ReplyKeyboardRemove(),
-    )
-    return STATE_DATE
+def _parse_datetime(text: str) -> datetime:
+    variants = ["%d.%m.%Y %H:%M", "%d.%m %H:%M", "%Y-%m-%d %H:%M"]
+    for fmt in variants:
+        try:
+            dt = datetime.strptime(text.strip(), fmt)
+            if fmt == "%d.%m %H:%M":
+                dt = dt.replace(year=datetime.now(TZ).year)
+            return dt.replace(tzinfo=TZ)
+        except ValueError:
+            continue
+    raise ValueError("invalid datetime")
 
 
-async def set_date_finish(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-    if not await _ensure_admin(update):
-        return ConversationHandler.END
-    text = update.message.text or ""
+async def _handle_view_reg(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
     try:
-        event_dt = _parse_datetime(text)
-    except ValueError:
-        await update.message.reply_text("–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å –¥–∞—Ç—É. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")
-        return STATE_DATE
-    settings = update_settings(current_event_datetime=event_dt.isoformat())
-    ensure_scheduler_started()
-    schedule_all_reminders(context.application)
-    await update.message.reply_text("–î–∞—Ç–∞ –≤–µ–±–∏–Ω–∞—Ä–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∞.", reply_markup=MENU_KEYBOARD)
-    await _send_event_card(update, settings)
-    return ConversationHandler.END
-
-
-def _is_valid_url(value: str) -> bool:
-    pattern = re.compile(r"^https?://.+$", re.IGNORECASE)
-    return bool(pattern.match(value))
-
-
-async def set_zoom_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-    if not await _ensure_admin(update):
-        return ConversationHandler.END
-    settings = await _maybe_require_new_event(update)
-    if settings is None:
-        return STATE_DECIDE_NEW_EVENT
-    await update.message.reply_text(
-        "–û—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–æ–≤—É—é Zoom-—Å—Å—ã–ª–∫—É.\n–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã: –û—Ç–º–µ–Ω–∞, –û—á–∏—Å—Ç–∏—Ç—å.",
-        reply_markup=ReplyKeyboardRemove(),
-    )
-    return STATE_ZOOM
-
-
-async def set_zoom_finish(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-    if not await _ensure_admin(update):
-        return ConversationHandler.END
-    text = update.message.text or ""
-    if _is_cancel(text):
-        await update.message.reply_text("–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ Zoom-—Å—Å—ã–ª–∫–∏ –æ—Ç–º–µ–Ω–µ–Ω–æ.", reply_markup=MENU_KEYBOARD)
-        return ConversationHandler.END
-    if _is_clear(text) or _is_skip(text):
-        settings = update_settings(zoom_link="")
-        await update.message.reply_text("–°—Å—ã–ª–∫–∞ Zoom –æ—á–∏—â–µ–Ω–∞.", reply_markup=MENU_KEYBOARD)
-        await _send_event_card(update, settings)
-        schedule_all_reminders(context.application)
-        return ConversationHandler.END
-    link = text.strip()
-    if not _is_valid_url(link):
-        await update.message.reply_text(
-            "–£–∫–∞–∂–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—É—é —Å—Å—ã–ª–∫—É (http/https) –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—ã –û—Ç–º–µ–Ω–∞/–û—á–∏—Å—Ç–∏—Ç—å/–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å."
+        df = database.get_participants()
+    except RuntimeError:
+        await show_admin_panel(
+            update,
+            context,
+            status_message="–ê–∫—Ç–∏–≤–Ω–æ–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–æ. –°–æ–∑–¥–∞–π—Ç–µ –Ω–æ–≤–æ–µ —Å–æ–±—ã—Ç–∏–µ.",
         )
-        return STATE_ZOOM
-    settings = update_settings(zoom_link=link)
-    await update.message.reply_text("–°—Å—ã–ª–∫–∞ Zoom –æ–±–Ω–æ–≤–ª–µ–Ω–∞.", reply_markup=MENU_KEYBOARD)
-    await _send_event_card(update, settings)
-    schedule_all_reminders(context.application)
-    return ConversationHandler.END
+        return ADMIN_PANEL
+    total = len(df.index)
+    preview = "\n".join(
+        f"‚Ä¢ {row.get('–ò–º—è') or row.get('–ò–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è') or row.get('Email') or '‚Äî'}"
+        for _, row in df.head(10).iterrows()
+    )
+    extra = f"–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–π: {total}"
+    if preview:
+        extra += f"\n–ü–µ—Ä–≤—ã–µ –∑–∞–ø–∏—Å–∏:\n{preview}"
+    await show_admin_panel(update, context, status_message=extra)
+    return ADMIN_PANEL
+
+
+async def _handle_broadcast(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
+    if update.callback_query:
+        await update.callback_query.answer()
+    await show_admin_panel(
+        update,
+        context,
+        status_message="–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è, –∫–æ—Ç–æ—Ä—ã–π –ø–æ–ª—É—á–∞—Ç –≤—Å–µ —É—á–∞—Å—Ç–Ω–∏–∫–∏.",
+    )
+    return WAITING_BROADCAST
 
 
-async def set_payment_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-    if not await _ensure_admin(update):
-        return ConversationHandler.END
-    settings = await _maybe_require_new_event(update)
-    if settings is None:
-        return STATE_DECIDE_NEW_EVENT
-    await update.message.reply_text(
-        "–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Å—Å—ã–ª–∫—É –Ω–∞ –æ–ø–ª–∞—Ç—É (http/https).\n–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã: –û—Ç–º–µ–Ω–∞, –û—á–∏—Å—Ç–∏—Ç—å, –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å.",
-        reply_markup=ReplyKeyboardRemove(),
+async def _handle_welcome(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
+    if update.callback_query:
+        await update.callback_query.answer()
+    await show_admin_panel(
+        update,
+        context,
+        status_message="–û—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–æ–≤—ã–π —Ç–µ–∫—Å—Ç –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏—è –¥–ª—è —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤.",
     )
-    return STATE_PAYMENT
+    return WAITING_WELCOME
 
 
-async def set_payment_finish(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-    if not await _ensure_admin(update):
-        return ConversationHandler.END
-    text = update.message.text or ""
-    if _is_cancel(text):
-        await update.message.reply_text("–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Å—ã–ª–∫–∏ –Ω–∞ –æ–ø–ª–∞—Ç—É –æ—Ç–º–µ–Ω–µ–Ω–æ.", reply_markup=MENU_KEYBOARD)
-        return ConversationHandler.END
-    if _is_clear(text) or _is_skip(text):
-        settings = update_settings(payment_link="")
-        await update.message.reply_text("–°—Å—ã–ª–∫–∞ –Ω–∞ –æ–ø–ª–∞—Ç—É –æ—á–∏—â–µ–Ω–∞.", reply_markup=MENU_KEYBOARD)
-        await _send_event_card(update, settings)
-        return ConversationHandler.END
-    link = text.strip()
-    if not _is_valid_url(link):
-        await update.message.reply_text(
-            "–£–∫–∞–∂–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—É—é —Å—Å—ã–ª–∫—É (http/https) –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—ã –û—Ç–º–µ–Ω–∞/–û—á–∏—Å—Ç–∏—Ç—å/–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å."
+async def _handle_open_sheet(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
+    try:
+        link = database.get_sheet_link()
+    except RuntimeError:
+        await show_admin_panel(
+            update,
+            context,
+            status_message="–ê–∫—Ç–∏–≤–Ω—ã–π –ª–∏—Å—Ç –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω. –°–æ–∑–¥–∞–π—Ç–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ.",
         )
-        return STATE_PAYMENT
-    settings = update_settings(payment_link=link)
-    await update.message.reply_text("–°—Å—ã–ª–∫–∞ –Ω–∞ –æ–ø–ª–∞—Ç—É –æ–±–Ω–æ–≤–ª–µ–Ω–∞.", reply_markup=MENU_KEYBOARD)
-    await _send_event_card(update, settings)
-    return ConversationHandler.END
+        return ADMIN_PANEL
+    await update.effective_chat.send_message(link, disable_web_page_preview=False)
+    await show_admin_panel(
+        update,
+        context,
+        status_message="–°—Å—ã–ª–∫–∞ –Ω–∞ Google Sheet –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –≤ —á–∞—Ç.",
+    )
+    return ADMIN_PANEL
 
 
-async def export_participants(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-    if not await _ensure_admin(update):
-        return ConversationHandler.END
+async def _handle_export(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
     try:
-        sheet_link = database.get_sheet_link()
+        path = database.export_database_csv()
     except RuntimeError:
-        await update.message.reply_text(
-            "–ê–∫—Ç–∏–≤–Ω—ã–π –ª–∏—Å—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω. –°–Ω–∞—á–∞–ª–∞ —Å–æ–∑–¥–∞–π—Ç–µ –Ω–æ–≤–æ–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ.",
-            reply_markup=MENU_KEYBOARD,
+        await show_admin_panel(
+            update,
+            context,
+            status_message="–ù–µ —É–¥–∞–ª–æ—Å—å —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å: –∞–∫—Ç–∏–≤–Ω–æ–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–æ.",
         )
-        return ConversationHandler.END
-    await update.message.reply_text(
-        f"üìä –°–ø–∏—Å–æ–∫ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤: {sheet_link}", reply_markup=MENU_KEYBOARD, disable_web_page_preview=True
+        return ADMIN_PANEL
+    await update.effective_chat.send_document(document=path.read_bytes(), filename=path.name)
+    await show_admin_panel(
+        update,
+        context,
+        status_message="CSV-—Ñ–∞–π–ª —Å–æ —Å–ø–∏—Å–∫–æ–º —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω.",
     )
-    path = database.export_database()
-    await update.message.reply_document(document=path.read_bytes(), filename=path.name)
-    return ConversationHandler.END
+    return ADMIN_PANEL
 
 
-async def notify_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-    if not await _ensure_admin(update):
-        return ConversationHandler.END
-    await update.message.reply_text(
-        "–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è, –∫–æ—Ç–æ—Ä—ã–π –±—É–¥–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –≤—Å–µ–º —É—á–∞—Å—Ç–Ω–∏–∫–∞–º:",
-        reply_markup=ReplyKeyboardRemove(),
+async def _handle_new_event(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
+    if update.callback_query:
+        await update.callback_query.answer()
+    context.user_data["new_event"] = {}
+    await show_admin_panel(
+        update,
+        context,
+        status_message="–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è.",
     )
-    return STATE_NOTIFY
+    return NEW_EVENT_TITLE
 
 
-async def notify_finish(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
+async def handle_admin_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
+    query = update.callback_query
+    if not query:
+        return ADMIN_PANEL
+    if not await _ensure_admin(update):
+        await query.answer()
+        return ConversationHandler.END
+    data = query.data
+    if data == CALLBACK_NEW_EVENT:
+        return await _handle_new_event(update, context)
+    if data == CALLBACK_VIEW_REG:
+        return await _handle_view_reg(update, context)
+    if data == CALLBACK_BROADCAST:
+        return await _handle_broadcast(update, context)
+    if data == CALLBACK_WELCOME:
+        return await _handle_welcome(update, context)
+    if data == CALLBACK_OPEN_SHEET:
+        return await _handle_open_sheet(update, context)
+    if data == CALLBACK_EXPORT_CSV:
+        return await _handle_export(update, context)
+    if data == CALLBACK_REFRESH:
+        await show_admin_panel(update, context)
+        return ADMIN_PANEL
+    await query.answer()
+    return ADMIN_PANEL
+
+
+async def handle_broadcast_text(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
     if not await _ensure_admin(update):
         return ConversationHandler.END
-    text = update.message.text or ""
+    text = (update.message.text or "").strip()
+    if not text:
+        await update.message.reply_text("–°–æ–æ–±—â–µ–Ω–∏–µ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")
+        return WAITING_BROADCAST
     participants = database.list_chat_ids()
     for chat_id in participants:
         await context.bot.send_message(chat_id=chat_id, text=text)
-    await update.message.reply_text("–†–∞—Å—Å—ã–ª–∫–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞.", reply_markup=MENU_KEYBOARD)
-    return ConversationHandler.END
-
-
-async def start_new_event_flow(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-    if not await _ensure_admin(update):
-        return ConversationHandler.END
-    context.user_data["new_event_data"] = {}
-    await update.message.reply_text(
-        "–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è.", reply_markup=ReplyKeyboardRemove()
-    )
-    return STATE_NEW_EVENT_TITLE
+    await show_admin_panel(update, context, status_message="–†–∞—Å—Å—ã–ª–∫–∞ —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞.")
+    return ADMIN_PANEL
 
 
-async def handle_new_event_decision(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
+async def handle_welcome_text(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
     if not await _ensure_admin(update):
         return ConversationHandler.END
     text = (update.message.text or "").strip()
-    if text == BUTTON_CREATE_NEW_PROMPT or text == BUTTON_NEW_EVENT:
-        return await start_new_event_flow(update, context)
-    await update.message.reply_text("–°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è –æ—Ç–º–µ–Ω–µ–Ω–æ.", reply_markup=MENU_KEYBOARD)
-    return ConversationHandler.END
+    if not text:
+        await update.message.reply_text("–ü—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.")
+        return WAITING_WELCOME
+    settings = update_settings(welcome_text=text)
+    await show_admin_panel(update, context, status_message="–ü—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ –æ–±–Ω–æ–≤–ª–µ–Ω–æ.")
+    return ADMIN_PANEL
 
 
 async def new_event_title(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
     if not await _ensure_admin(update):
         return ConversationHandler.END
     text = (update.message.text or "").strip()
-    if _is_cancel(text):
-        await update.message.reply_text("–°–æ–∑–¥–∞–Ω–∏–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è –æ—Ç–º–µ–Ω–µ–Ω–æ.", reply_markup=MENU_KEYBOARD)
-        context.user_data.pop("new_event_data", None)
-        return ConversationHandler.END
     if not text:
         await update.message.reply_text("–ù–∞–∑–≤–∞–Ω–∏–µ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")
-        return STATE_NEW_EVENT_TITLE
-    context.user_data.setdefault("new_event_data", {})["topic"] = text
-    await update.message.reply_text(
-        "–û—Ç–ø—Ä–∞–≤—å—Ç–µ –æ–ø–∏—Å–∞–Ω–∏–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è.\n–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã: –û—Ç–º–µ–Ω–∞, –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å.",
-        reply_markup=ReplyKeyboardRemove(),
-    )
-    return STATE_NEW_EVENT_DESCRIPTION
+        return NEW_EVENT_TITLE
+    context.user_data.setdefault("new_event", {})["topic"] = text
+    await show_admin_panel(update, context, status_message="–í–≤–µ–¥–∏—Ç–µ –æ–ø–∏—Å–∞–Ω–∏–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è (–º–æ–∂–Ω–æ –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å –ø—É—Å—Ç—ã–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º).")
+    return NEW_EVENT_DESCRIPTION
 
 
 async def new_event_description(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
     if not await _ensure_admin(update):
         return ConversationHandler.END
-    text = update.message.text or ""
-    data = context.user_data.setdefault("new_event_data", {})
-    if _is_cancel(text):
-        await update.message.reply_text("–°–æ–∑–¥–∞–Ω–∏–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è –æ—Ç–º–µ–Ω–µ–Ω–æ.", reply_markup=MENU_KEYBOARD)
-        context.user_data.pop("new_event_data", None)
-        return ConversationHandler.END
-    if _is_skip(text):
-        data["description"] = ""
-    else:
-        data["description"] = text.strip()
-    await update.message.reply_text(
-        "–í–≤–µ–¥–∏—Ç–µ –¥–∞—Ç—É –∏ –≤—Ä–µ–º—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ –î–î.–ú–ú.–ì–ì–ì–ì –ß–ß:–ú–ú –∏–ª–∏ –î–î.–ú–ú –ß–ß:–ú–ú.",
-        reply_markup=ReplyKeyboardRemove(),
+    text = (update.message.text or "").strip()
+    context.user_data.setdefault("new_event", {})["description"] = text
+    await show_admin_panel(
+        update,
+        context,
+        status_message="–í–≤–µ–¥–∏—Ç–µ –¥–∞—Ç—É –∏ –≤—Ä–µ–º—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ –î–î.–ú–ú.–ì–ì–ì–ì –ß–ß:–ú–ú –∏–ª–∏ –î–î.–ú–ú –ß–ß:–ú–ú.",
     )
-    return STATE_NEW_EVENT_DATETIME
+    return NEW_EVENT_DATETIME
 
 
 async def new_event_datetime(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
     if not await _ensure_admin(update):
         return ConversationHandler.END
-    text = update.message.text or ""
+    text = (update.message.text or "").strip()
     try:
-        event_dt = _parse_datetime(text)
+        dt = _parse_datetime(text)
     except ValueError:
         await update.message.reply_text("–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å –¥–∞—Ç—É. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")
-        return STATE_NEW_EVENT_DATETIME
-    context.user_data.setdefault("new_event_data", {})["datetime"] = event_dt
-    await update.message.reply_text(
-        "–£–∫–∞–∂–∏—Ç–µ Zoom-—Å—Å—ã–ª–∫—É. –î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã: –û—Ç–º–µ–Ω–∞, –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å.",
-        reply_markup=ReplyKeyboardRemove(),
-    )
-    return STATE_NEW_EVENT_ZOOM
+        return NEW_EVENT_DATETIME
+    context.user_data.setdefault("new_event", {})["datetime"] = dt
+    await show_admin_panel(update, context, status_message="–£–∫–∞–∂–∏—Ç–µ —Å—Å—ã–ª–∫—É –Ω–∞ Zoom (–∏–ª–∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –ø—É—Å—Ç–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ).")
+    return NEW_EVENT_ZOOM
 
 
 async def new_event_zoom(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
     if not await _ensure_admin(update):
         return ConversationHandler.END
-    text = update.message.text or ""
-    data = context.user_data.setdefault("new_event_data", {})
-    if _is_cancel(text):
-        await update.message.reply_text("–°–æ–∑–¥–∞–Ω–∏–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è –æ—Ç–º–µ–Ω–µ–Ω–æ.", reply_markup=MENU_KEYBOARD)
-        context.user_data.pop("new_event_data", None)
-        return ConversationHandler.END
-    if _is_skip(text) or _is_clear(text):
-        data["zoom_link"] = ""
-    else:
-        link = text.strip()
-        if not _is_valid_url(link):
-            await update.message.reply_text(
-                "–£–∫–∞–∂–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—É—é —Å—Å—ã–ª–∫—É (http/https) –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—ã –û—Ç–º–µ–Ω–∞/–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å."
-            )
-            return STATE_NEW_EVENT_ZOOM
-        data["zoom_link"] = link
-    await update.message.reply_text(
-        "–£–∫–∞–∂–∏—Ç–µ —Å—Å—ã–ª–∫—É –Ω–∞ –æ–ø–ª–∞—Ç—É. –î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã: –û—Ç–º–µ–Ω–∞, –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å.",
-        reply_markup=ReplyKeyboardRemove(),
-    )
-    return STATE_NEW_EVENT_PAYMENT
+    text = (update.message.text or "").strip()
+    context.user_data.setdefault("new_event", {})["zoom_link"] = text
+    await show_admin_panel(update, context, status_message="–£–∫–∞–∂–∏—Ç–µ —Å—Å—ã–ª–∫—É –Ω–∞ –æ–ø–ª–∞—Ç—É (–∏–ª–∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –ø—É—Å—Ç–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ).")
+    return NEW_EVENT_PAYMENT
 
 
 async def _finalize_new_event(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-    data = context.user_data.get("new_event_data") or {}
+    data = context.user_data.get("new_event") or {}
     topic = data.get("topic")
     event_dt: Optional[datetime] = data.get("datetime")
     if not topic or not event_dt:
-        await update.message.reply_text(
-            "–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.",
-            reply_markup=MENU_KEYBOARD,
+        await show_admin_panel(
+            update,
+            context,
+            status_message="–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è.",
         )
-        context.user_data.pop("new_event_data", None)
-        return ConversationHandler.END
+        context.user_data.pop("new_event", None)
+        return ADMIN_PANEL
+    description = data.get("description", "")
+    zoom_link = data.get("zoom_link", "")
+    payment_link = data.get("payment_link", "")
 
     sheet_name = _generate_sheet_name(topic, event_dt)
     worksheet = database.get_or_create_sheet(sheet_name)
     event_id = _generate_event_id()
 
-    settings = update_settings(
+    update_settings(
         topic=topic,
-        description=data.get("description", ""),
-        zoom_link=data.get("zoom_link", ""),
-        payment_link=data.get("payment_link", ""),
+        description=description,
+        zoom_link=zoom_link,
+        payment_link=payment_link,
         current_event_id=event_id,
         current_event_sheet_name=worksheet.title,
         current_event_sheet_gid=worksheet.id,
         current_event_datetime=event_dt.isoformat(),
         timezone=TIMEZONE,
     )
 
-    context.user_data.pop("new_event_data", None)
+    context.user_data.pop("new_event", None)
     ensure_scheduler_started()
     schedule_all_reminders(context.application)
 
-    sheet_link = database.get_sheet_link(worksheet.title, worksheet.id)
-    await update.message.reply_text(
-        "–ù–æ–≤–æ–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ —Å–æ–∑–¥–∞–Ω–æ ‚úÖ\n"
-        f"–õ–∏—Å—Ç —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤: {sheet_link}",
-        disable_web_page_preview=True,
-        reply_markup=MENU_KEYBOARD,
+    link = database.get_sheet_link(worksheet.title, worksheet.id)
+    await show_admin_panel(
+        update,
+        context,
+        status_message=f"–ù–æ–≤–æ–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ —Å–æ–∑–¥–∞–Ω–æ. –°—Å—ã–ª–∫–∞ –Ω–∞ –ª–∏—Å—Ç: {link}",
     )
-    await _send_event_card(update, settings)
-    return ConversationHandler.END
+    return ADMIN_PANEL
 
 
 async def new_event_payment(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
     if not await _ensure_admin(update):
         return ConversationHandler.END
-    text = update.message.text or ""
-    data = context.user_data.setdefault("new_event_data", {})
-    if _is_cancel(text):
-        await update.message.reply_text("–°–æ–∑–¥–∞–Ω–∏–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è –æ—Ç–º–µ–Ω–µ–Ω–æ.", reply_markup=MENU_KEYBOARD)
-        context.user_data.pop("new_event_data", None)
-        return ConversationHandler.END
-    if _is_skip(text) or _is_clear(text):
-        data["payment_link"] = ""
-    else:
-        link = text.strip()
-        if not _is_valid_url(link):
-            await update.message.reply_text(
-                "–£–∫–∞–∂–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—É—é —Å—Å—ã–ª–∫—É (http/https) –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—ã –û—Ç–º–µ–Ω–∞/–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å."
-            )
-            return STATE_NEW_EVENT_PAYMENT
-        data["payment_link"] = link
+    text = (update.message.text or "").strip()
+    context.user_data.setdefault("new_event", {})["payment_link"] = text
     return await _finalize_new_event(update, context)
 
 
+async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
+    if not await _ensure_admin(update):
+        return ConversationHandler.END
+    await update.message.reply_text("–î–µ–π—Å—Ç–≤–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ.")
+    context.user_data.pop("new_event", None)
+    await show_admin_panel(update, context)
+    return ADMIN_PANEL
+
+
 def build_admin_conversation() -> ConversationHandler:
     return ConversationHandler(
-        entry_points=[
-            CommandHandler("admin", admin_command_entry),
-            CommandHandler("set_topic", set_topic_start),
-            CommandHandler("set_date", set_date_start),
-            CommandHandler("set_zoom", set_zoom_start),
-            CommandHandler("set_payment", set_payment_start),
-            CommandHandler("export", export_participants),
-            CommandHandler("notify", notify_start),
-            CommandHandler("current_event", show_current_event),
-            CommandHandler("new_event", start_new_event_flow),
-            MessageHandler(filters.Regex(f"^{re.escape(BUTTON_SET_TOPIC)}$"), set_topic_start),
-            MessageHandler(filters.Regex(f"^{re.escape(BUTTON_SET_DESCRIPTION)}$"), set_description_start),
-            MessageHandler(filters.Regex(f"^{re.escape(BUTTON_SET_DATE)}$"), set_date_start),
-            MessageHandler(filters.Regex(f"^{re.escape(BUTTON_SET_ZOOM)}$"), set_zoom_start),
-            MessageHandler(filters.Regex(f"^{re.escape(BUTTON_SET_PAYMENT)}$"), set_payment_start),
-            MessageHandler(filters.Regex(f"^{re.escape(BUTTON_EXPORT)}$"), export_participants),
-            MessageHandler(filters.Regex(f"^{re.escape(BUTTON_NOTIFY)}$"), notify_start),
-            MessageHandler(filters.Regex(f"^{re.escape(BUTTON_SHOW_EVENT)}$"), show_current_event),
-            MessageHandler(filters.Regex(f"^{re.escape(BUTTON_NEW_EVENT)}$"), start_new_event_flow),
-        ],
+        entry_points=[CommandHandler("admin", admin_command_entry)],
         states={
-            STATE_TOPIC: [MessageHandler(filters.TEXT & ~filters.COMMAND, set_topic_finish)],
-            STATE_DESCRIPTION: [
-                MessageHandler(filters.TEXT & ~filters.COMMAND, set_description_finish)
-            ],
-            STATE_DATE: [MessageHandler(filters.TEXT & ~filters.COMMAND, set_date_finish)],
-            STATE_ZOOM: [MessageHandler(filters.TEXT & ~filters.COMMAND, set_zoom_finish)],
-            STATE_PAYMENT: [MessageHandler(filters.TEXT & ~filters.COMMAND, set_payment_finish)],
-            STATE_NOTIFY: [MessageHandler(filters.TEXT & ~filters.COMMAND, notify_finish)],
-            STATE_DECIDE_NEW_EVENT: [
-                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_new_event_decision)
-            ],
-            STATE_NEW_EVENT_TITLE: [
-                MessageHandler(filters.TEXT & ~filters.COMMAND, new_event_title)
-            ],
-            STATE_NEW_EVENT_DESCRIPTION: [
+            ADMIN_PANEL: [CallbackQueryHandler(handle_admin_callback, pattern=r"^admin:")],
+            WAITING_BROADCAST: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_broadcast_text)],
+            WAITING_WELCOME: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_welcome_text)],
+            NEW_EVENT_TITLE: [MessageHandler(filters.TEXT & ~filters.COMMAND, new_event_title)],
+            NEW_EVENT_DESCRIPTION: [
                 MessageHandler(filters.TEXT & ~filters.COMMAND, new_event_description)
             ],
-            STATE_NEW_EVENT_DATETIME: [
+            NEW_EVENT_DATETIME: [
                 MessageHandler(filters.TEXT & ~filters.COMMAND, new_event_datetime)
             ],
-            STATE_NEW_EVENT_ZOOM: [
-                MessageHandler(filters.TEXT & ~filters.COMMAND, new_event_zoom)
-            ],
-            STATE_NEW_EVENT_PAYMENT: [
+            NEW_EVENT_ZOOM: [MessageHandler(filters.TEXT & ~filters.COMMAND, new_event_zoom)],
+            NEW_EVENT_PAYMENT: [
                 MessageHandler(filters.TEXT & ~filters.COMMAND, new_event_payment)
             ],
         },
-        fallbacks=[CommandHandler("cancel", admin_command_entry)],
+        fallbacks=[CommandHandler("cancel", cancel)],
         allow_reentry=True,
     )
-
diff --git a/config.py b/config.py
index 787e3634820c56eac2660098d72df003cb75a797..c98a1c79e4ccc3f1fb4ccf97e7e71e3cbfc22a96 100644
--- a/config.py
+++ b/config.py
@@ -9,50 +9,51 @@ from typing import Any, Dict, Optional, Tuple
 BOT_TOKEN: str = "8439661494:AAG5nqW5raGjVjocSX6L8oCS1hZngqdq-Uo"
 
 # Administrators who can access privileged commands.
 ADMINS: Tuple[Dict[str, Any], ...] = (
     {
         "chat_id": 7740254761,
         "username": "z_ivan89",
     },
 )
 
 
 # === Google Sheets Integration ===
 GSPREAD_CREDENTIALS_PATH = "./service_account.json"
 GSPREAD_SHEET_ID = "1f5bRTFlKQ3FD-u0cggKj-87HdXNzMwz_H8imefFaNmI"
 TIMEZONE = "Europe/Moscow"
 
 
 
 # Storage locations
 DATA_DIR = Path("data")
 SETTINGS_FILE = DATA_DIR / "config.json"
 
 _DEFAULT_SETTINGS: Dict[str, Any] = {
     "topic": "–ü—Å–∏—Ö–æ–ª–æ–≥–∏—á–µ—Å–∫–∏–π –≤–µ–±–∏–Ω–∞—Ä",
     "description": "–ê–≤—Ç–æ—Ä—Å–∫–∏–π –≤–µ–±–∏–Ω–∞—Ä –ø–æ –ø—Å–∏—Ö–æ–ª–æ–≥–∏–∏",
+    "welcome_text": "–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å! –ó–¥–µ—Å—å –≤—ã –º–æ–∂–µ—Ç–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å—Å—è –Ω–∞ –±–ª–∏–∂–∞–π—à–µ–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ.",
     "current_event_id": None,
     "current_event_sheet_name": None,
     "current_event_sheet_gid": None,
     "current_event_datetime": None,  # ISO formatted date time string in TIMEZONE
     "zoom_link": "",
     "payment_link": "",
     "timezone": TIMEZONE,
 }
 
 
 def is_admin(chat_id: Optional[int] = None, username: Optional[str] = None) -> bool:
     """Return True if provided identifiers match a known administrator."""
 
     normalized_username = (username or "").lstrip("@").lower()
     for admin in ADMINS:
         admin_chat_id = admin.get("chat_id")
         admin_username = (admin.get("username") or "").lstrip("@").lower()
 
         if chat_id is not None and admin_chat_id == chat_id:
             return True
         if normalized_username and admin_username and normalized_username == admin_username:
             return True
     return False
 
 
diff --git a/database.py b/database.py
index 0d19778a423b7b2dcd4de515bfb0facf2d132d50..ca3062c7b00906c098be026b97c42cefc871fd35 100644
--- a/database.py
+++ b/database.py
@@ -207,50 +207,73 @@ def register_participant(participant: Participant) -> None:
             "chat_id": str(participant.chat_id),
             "–ò–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è": username,
             "–ò–º—è": participant.name,
             "Email": participant.email,
         }
     )
 
     role_value = data.get("–¢–∏–ø —É—á–∞—Å—Ç–∏—è") or participant.role
     paid_value = data.get("–°—Ç–∞—Ç—É—Å –æ–ø–ª–∞—Ç—ã") or participant.paid
     feedback_value = data.get("–û–±—Ä–∞—Ç–Ω–∞—è —Å–≤—è–∑—å") or participant.feedback
 
     data["–¢–∏–ø —É—á–∞—Å—Ç–∏—è"] = _format_role(role_value)
     data["–°—Ç–∞—Ç—É—Å –æ–ø–ª–∞—Ç—ã"] = _format_payment_status(paid_value)
     data["–û–±—Ä–∞—Ç–Ω–∞—è —Å–≤—è–∑—å"] = feedback_value
 
     row_values = [data.get(header, "") for header in HEADERS]
 
     if row_idx:
         start = rowcol_to_a1(row_idx, 1)
         end = rowcol_to_a1(row_idx, len(HEADERS))
         worksheet.update(f"{start}:{end}", [row_values])
     else:
         worksheet.append_row(row_values)
 
 
+def get_participant(chat_id: int) -> Optional[Dict[str, str]]:
+    """Return participant row mapped by headers or ``None`` if missing."""
+
+    worksheet = get_current_worksheet()
+    header_map = _header_map(worksheet)
+    row_idx = _find_row_by_chat_id(worksheet, chat_id, header_map)
+    if not row_idx:
+        return None
+    return _row_dict(worksheet, row_idx, header_map)
+
+
+def unregister_participant(chat_id: int) -> bool:
+    """Remove participant from the current worksheet."""
+
+    worksheet = get_current_worksheet()
+    header_map = _header_map(worksheet)
+    row_idx = _find_row_by_chat_id(worksheet, chat_id, header_map)
+    if not row_idx:
+        return False
+    worksheet.delete_rows(row_idx)
+    return True
+
+
 def update_participation(chat_id: int, role: str, paid: str) -> None:
     worksheet = get_current_worksheet()
     header_map = _header_map(worksheet)
     row_idx = _find_row_by_chat_id(worksheet, chat_id, header_map)
     if not row_idx:
         return
     role_value = _format_role(role)
     paid_value = _format_payment_status(paid)
     role_col = header_map.get("–¢–∏–ø —É—á–∞—Å—Ç–∏—è")
     paid_col = header_map.get("–°—Ç–∞—Ç—É—Å –æ–ø–ª–∞—Ç—ã")
     if not role_col or not paid_col:
         return
     start_col = min(role_col, paid_col)
     end_col = max(role_col, paid_col)
     start = rowcol_to_a1(row_idx, start_col)
     end = rowcol_to_a1(row_idx, end_col)
     if role_col <= paid_col:
         values = [[role_value, paid_value]]
     else:
         values = [[paid_value, role_value]]
     worksheet.update(f"{start}:{end}", values)
 
 
 def update_feedback(chat_id: int, feedback: str) -> None:
     worksheet = get_current_worksheet()
@@ -280,46 +303,57 @@ def list_chat_ids() -> List[int]:
     if not chat_col:
         return []
     values = worksheet.col_values(chat_col)
     chat_ids: List[int] = []
     for value in values[1:]:  # skip header
         value = value.strip()
         if not value:
             continue
         try:
             chat_ids.append(int(float(value)))
         except ValueError:
             continue
     return chat_ids
 
 
 def export_database(destination: Optional[Path] = None) -> Path:
     """Create an XLSX export of the current participant list."""
     df = get_participants()
     if destination is None:
         destination = DATA_DIR / "participants.xlsx"
     destination.parent.mkdir(parents=True, exist_ok=True)
     df.to_excel(destination, index=False)
     return destination
 
 
+def export_database_csv(destination: Optional[Path] = None) -> Path:
+    """Create a CSV export of the current participant list."""
+
+    df = get_participants()
+    if destination is None:
+        destination = DATA_DIR / "participants.csv"
+    destination.parent.mkdir(parents=True, exist_ok=True)
+    df.to_csv(destination, index=False)
+    return destination
+
+
 def get_sheet_link(sheet_name: Optional[str] = None, gid: Optional[int] = None) -> str:
     if sheet_name is None:
         settings = load_settings()
         sheet_name = settings.get("current_event_sheet_name")
         gid = settings.get("current_event_sheet_gid")
     if not sheet_name:
         raise RuntimeError("–ê–∫—Ç–∏–≤–Ω—ã–π –ª–∏—Å—Ç —Å–æ–±—ã—Ç–∏—è –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω")
     if gid is None:
         worksheet = get_sheet_by_name(sheet_name)
         if worksheet is None:
             worksheet = create_event_sheet(sheet_name)
         gid = worksheet.id
     return f"https://docs.google.com/spreadsheets/d/{GSPREAD_SHEET_ID}/edit#gid={gid}"
 
 
 def get_or_create_sheet(sheet_name: str) -> gspread.Worksheet:
     worksheet = get_sheet_by_name(sheet_name)
     if worksheet is None:
         worksheet = create_event_sheet(sheet_name)
     return worksheet
 
diff --git a/handlers.py b/handlers.py
index 27f54e1bb3e61d8cb507552d40e445f6441bae0b..b88d700d7860950845ee8146c1c9cbc0b1795cb8 100644
--- a/handlers.py
+++ b/handlers.py
@@ -1,126 +1,527 @@
-"""User interaction handlers for the psychology webinar bot."""
+"""Inline user interaction handlers for the psychology webinar bot."""
 from __future__ import annotations
 
 import re
+from dataclasses import dataclass
+from datetime import datetime, timedelta
+from typing import Optional
 
-from telegram import ReplyKeyboardMarkup, ReplyKeyboardRemove, Update
+from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
 from telegram.ext import (
+    CallbackQueryHandler,
     CommandHandler,
     ContextTypes,
     ConversationHandler,
     MessageHandler,
     filters,
 )
 
 import database
-from config import is_admin, load_settings
-from message_templates import (
-    build_free_confirmation,
-    build_paid_pending_confirmation,
-)
-
-WAITING_EMAIL, WAITING_FORMAT = range(2)
-FREE_BUTTON = "üÜì –ù–∞–±–ª—é–¥–∞—Ç–µ–ª—å (–±–µ—Å–ø–ª–∞—Ç–Ω–æ)"
-PAID_BUTTON = "üí∞ –£—á–∞—Å—Ç–Ω–∏–∫ —Å —Ä–∞–∑–±–æ—Ä–æ–º (–ø–ª–∞—Ç–Ω–æ)"
+from config import TIMEZONE, is_admin, load_settings
+from message_templates import build_free_confirmation, get_event_context
+from notifications import send_paid_confirmation
+from reminders import cancel_personal_reminder, schedule_personal_reminder
+from zoneinfo import ZoneInfo
 
 EMAIL_REGEX = re.compile(r"^[^@\s]+@[^@\s]+\.[^@\s]+$")
 
+PANEL, WAITING_EMAIL, WAITING_FEEDBACK = range(3)
+
+USER_REGISTER = "user:register"
+USER_REMIND_HOUR = "user:remind:hour"
+USER_REMIND_DAY = "user:remind:day"
+USER_UNSUBSCRIBE = "user:unsubscribe"
+USER_CONFIRMED_PAYMENT = "user:paid"
+USER_FEEDBACK = "user:feedback"
+USER_LOCATION = "user:location"
+USER_CALENDAR = "user:calendar"
+
+REMINDER_HOUR = "hour"
+REMINDER_DAY = "day"
+TZ = ZoneInfo(TIMEZONE)
+
+
+@dataclass
+class ParticipantStatus:
+    registered: bool
+    paid: bool
+    role: str = ""
+    email: str = ""
+
+
+def _get_event_datetime(settings: Optional[dict] = None) -> Optional[datetime]:
+    if settings is None:
+        settings = load_settings()
+    event_iso = settings.get("current_event_datetime")
+    if not event_iso:
+        return None
+    try:
+        return datetime.fromisoformat(str(event_iso))
+    except ValueError:
+        return None
+
+
+def _participant_status(chat_id: int) -> ParticipantStatus:
+    row = database.get_participant(chat_id)
+    if not row:
+        return ParticipantStatus(registered=False, paid=False)
+    role_value = (row.get("–¢–∏–ø —É—á–∞—Å—Ç–∏—è") or "").strip().lower()
+    paid_value = (row.get("–°—Ç–∞—Ç—É—Å –æ–ø–ª–∞—Ç—ã") or "").strip().lower()
+    paid = paid_value in {"–æ–ø–ª–∞—á–µ–Ω–æ", "–æ–ø–ª–∞—Ç–∏–ª", "–æ–ø–ª–∞—Ç–∏–ª–∞", "paid", "yes", "–¥–∞"}
+    return ParticipantStatus(
+        registered=True,
+        paid=paid,
+        role=role_value,
+        email=(row.get("Email") or "").strip(),
+    )
+
+
+def _build_status_text(status: ParticipantStatus) -> str:
+    if not status.registered:
+        return "üü° –°—Ç–∞—Ç—É—Å: –≤—ã –µ—â—ë –Ω–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã."
+    if status.paid:
+        return "üü¢ –°—Ç–∞—Ç—É—Å: —É—á–∞—Å—Ç–∏–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–æ (–æ–ø–ª–∞—á–µ–Ω–æ)."
+    return "üü† –°—Ç–∞—Ç—É—Å: —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –ø–æ–ª—É—á–µ–Ω–∞, –æ–∂–∏–¥–∞–µ–º –æ–ø–ª–∞—Ç—É."
+
+
+def _build_event_message(settings: dict, status: ParticipantStatus, extra: Optional[str] = None) -> str:
+    ctx = get_event_context(settings)
+    welcome = (settings.get("welcome_text") or "").strip()
+    lines = []
+    if welcome:
+        lines.append(welcome)
+    lines.append(f"üß† –ú–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ: {ctx['title']}")
+    lines.append(f"üìù {ctx['description']}")
+    lines.append(f"üìÖ {ctx['local_datetime']} ({ctx['timezone']})")
+    zoom_link = settings.get("zoom_link") or ""
+    if zoom_link:
+        lines.append(f"üîó Zoom: {zoom_link}")
+    payment = settings.get("payment_link") or ""
+    if payment:
+        lines.append(f"üí≥ –û–ø–ª–∞—Ç–∞: {payment}")
+    lines.append("")
+    lines.append(_build_status_text(status))
+    if extra:
+        lines.append("")
+        lines.append(extra)
+    return "\n".join(lines)
+
+
+def _build_user_keyboard(status: ParticipantStatus) -> InlineKeyboardMarkup:
+    keyboard: list[list[InlineKeyboardButton]] = []
+    if not status.registered:
+        keyboard.append([InlineKeyboardButton("‚úÖ –ó–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å—Å—è", callback_data=USER_REGISTER)])
+    else:
+        keyboard.append(
+            [
+                InlineKeyboardButton("üîî –ù–∞–ø–æ–º–Ω–∏—Ç—å –∑–∞ 1 —á–∞—Å", callback_data=USER_REMIND_HOUR),
+                InlineKeyboardButton("‚è∞ –ù–∞–ø–æ–º–Ω–∏—Ç—å –∑–∞ 1 –¥–µ–Ω—å", callback_data=USER_REMIND_DAY),
+            ]
+        )
+        keyboard.append([InlineKeyboardButton("‚ùå –û—Ç–ø–∏—Å–∞—Ç—å—Å—è", callback_data=USER_UNSUBSCRIBE)])
+        if not status.paid:
+            keyboard.append([InlineKeyboardButton("üí≥ –Ø –æ–ø–ª–∞—Ç–∏–ª(–∞)", callback_data=USER_CONFIRMED_PAYMENT)])
+    keyboard.append([InlineKeyboardButton("üìù –û—Å—Ç–∞–≤–∏—Ç—å –æ—Ç–∑—ã–≤", callback_data=USER_FEEDBACK)])
+    keyboard.append([InlineKeyboardButton("üìç –õ–æ–∫–∞—Ü–∏—è/—Å—Å—ã–ª–∫–∞", callback_data=USER_LOCATION)])
+    keyboard.append([InlineKeyboardButton("üóì –î–æ–±–∞–≤–∏—Ç—å –≤ –∫–∞–ª–µ–Ω–¥–∞—Ä—å", callback_data=USER_CALENDAR)])
+    return InlineKeyboardMarkup(keyboard)
+
+
+async def _render_user_panel(
+    *,
+    update: Update,
+    context: ContextTypes.DEFAULT_TYPE,
+    status_message: Optional[str] = None,
+) -> None:
+    chat = update.effective_chat
+    if chat is None:
+        return
+    chat_id = chat.id
+    settings = load_settings()
+    status = _participant_status(chat_id)
+    text = _build_event_message(settings, status, status_message)
+    keyboard = _build_user_keyboard(status)
+    if update.callback_query and update.callback_query.message:
+        await update.callback_query.message.edit_text(
+            text,
+            reply_markup=keyboard,
+            disable_web_page_preview=True,
+        )
+        context.user_data["panel_message_id"] = update.callback_query.message.message_id
+    elif update.message:
+        sent = await update.message.reply_text(
+            text,
+            reply_markup=keyboard,
+            disable_web_page_preview=True,
+        )
+        context.user_data["panel_message_id"] = sent.message_id
+    else:
+        sent = await context.bot.send_message(
+            chat_id=chat_id,
+            text=text,
+            reply_markup=keyboard,
+            disable_web_page_preview=True,
+        )
+        context.user_data["panel_message_id"] = sent.message_id
+
+
+async def _refresh_panel_from_state(
+    *,
+    context: ContextTypes.DEFAULT_TYPE,
+    chat_id: int,
+    status_message: Optional[str] = None,
+) -> None:
+    message_id = context.user_data.get("panel_message_id")
+    settings = load_settings()
+    status = _participant_status(chat_id)
+    text = _build_event_message(settings, status, status_message)
+    keyboard = _build_user_keyboard(status)
+    if message_id:
+        try:
+            await context.bot.edit_message_text(
+                chat_id=chat_id,
+                message_id=message_id,
+                text=text,
+                reply_markup=keyboard,
+                disable_web_page_preview=True,
+            )
+            return
+        except Exception:
+            pass
+    await context.bot.send_message(
+        chat_id=chat_id,
+        text=text,
+        reply_markup=keyboard,
+        disable_web_page_preview=True,
+    )
+
 
 async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
     user = update.effective_user
     if user and is_admin(chat_id=user.id, username=user.username):
-        from admin_panel import send_admin_panel
+        from admin_panel import show_admin_panel
 
-        await send_admin_panel(update, context)
+        await show_admin_panel(update, context)
         return ConversationHandler.END
 
-    await update.message.reply_text(
-        "–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –Ω–∞ –≤–µ–±–∏–Ω–∞—Ä –ø–æ –ø—Å–∏—Ö–æ–ª–æ–≥–∏–∏!\n"
-        "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ –≤–∞—à e-mail –¥–ª—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏.",
-        reply_markup=ReplyKeyboardRemove(),
+    await _render_user_panel(update=update, context=context)
+    context.user_data.pop("awaiting_email", None)
+    context.user_data.pop("awaiting_feedback", None)
+    return PANEL
+
+
+async def _handle_registration(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
+    query = update.callback_query
+    if query:
+        await query.answer()
+    chat_id = update.effective_chat.id
+    status = _participant_status(chat_id)
+    if status.registered:
+        await _render_user_panel(update=update, context=context, status_message="–í—ã —É–∂–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã.")
+        return PANEL
+    context.user_data["awaiting_email"] = True
+    await _render_user_panel(
+        update=update,
+        context=context,
+        status_message="–û—Ç–ø—Ä–∞–≤—å—Ç–µ, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–∞—à e-mail –æ–¥–Ω–∏–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º.",
     )
     return WAITING_EMAIL
 
 
+async def _handle_reminder(
+    update: Update,
+    context: ContextTypes.DEFAULT_TYPE,
+    label: str,
+) -> int:
+    query = update.callback_query
+    if query:
+        await query.answer()
+    chat_id = update.effective_chat.id
+    status = _participant_status(chat_id)
+    if not status.registered:
+        await _render_user_panel(
+            update=update,
+            context=context,
+            status_message="–°–Ω–∞—á–∞–ª–∞ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–π—Ç–µ—Å—å, —á—Ç–æ–±—ã –Ω–∞—Å—Ç—Ä–∞–∏–≤–∞—Ç—å –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è.",
+        )
+        return PANEL
+
+    settings = load_settings()
+    event_dt = _get_event_datetime(settings)
+    if not event_dt:
+        await _render_user_panel(
+            update=update,
+            context=context,
+            status_message="–î–∞—Ç–∞ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è –ø–æ–∫–∞ –Ω–µ —É–∫–∞–∑–∞–Ω–∞. –ú—ã –Ω–∞–ø–æ–º–Ω–∏–º –ø–æ–∑–∂–µ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏.",
+        )
+        return PANEL
+
+    if label == REMINDER_DAY:
+        run_at = event_dt - timedelta(days=1)
+        message = "–ù–∞–ø–æ–º–∏–Ω–∞–µ–º: –¥–æ –Ω–∞—á–∞–ª–∞ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è –æ—Å—Ç–∞–ª—Å—è –æ–¥–∏–Ω –¥–µ–Ω—å!"
+    else:
+        run_at = event_dt - timedelta(hours=1)
+        message = "–ß–µ—Ä–µ–∑ —á–∞—Å –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ. –î–æ –≤—Å—Ç—Ä–µ—á–∏!"
+
+    scheduled = schedule_personal_reminder(
+        context,
+        chat_id=chat_id,
+        run_at=run_at,
+        message=message,
+        label=label,
+    )
+    if not scheduled:
+        await _render_user_panel(
+            update=update,
+            context=context,
+            status_message="–≠—Ç–æ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ —É–∂–µ –Ω–µ–∞–∫—Ç—É–∞–ª—å–Ω–æ, –≤—Ä–µ–º—è –ø—Ä–æ—à–ª–æ.",
+        )
+        return PANEL
+    local_dt = scheduled.astimezone(TZ)
+    await _render_user_panel(
+        update=update,
+        context=context,
+        status_message=f"–õ–∏—á–Ω–æ–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–æ –Ω–∞ {local_dt.strftime('%d.%m %H:%M')}.",
+    )
+    return PANEL
+
+
+async def _handle_unsubscribe(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
+    query = update.callback_query
+    if query:
+        await query.answer()
+    chat_id = update.effective_chat.id
+    if database.unregister_participant(chat_id):
+        cancel_personal_reminder(context, chat_id, REMINDER_DAY)
+        cancel_personal_reminder(context, chat_id, REMINDER_HOUR)
+        await _render_user_panel(
+            update=update,
+            context=context,
+            status_message="–í—ã —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø–∏—Å–∞–ª–∏—Å—å –æ—Ç —É—á–∞—Å—Ç–∏—è.",
+        )
+    else:
+        await _render_user_panel(
+            update=update,
+            context=context,
+            status_message="–ê–∫—Ç–∏–≤–Ω–æ–π —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.",
+        )
+    return PANEL
+
+
+async def _handle_payment_confirmation(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
+    query = update.callback_query
+    if query:
+        await query.answer()
+    chat_id = update.effective_chat.id
+    status = _participant_status(chat_id)
+    if not status.registered:
+        await _render_user_panel(
+            update=update,
+            context=context,
+            status_message="–°–Ω–∞—á–∞–ª–∞ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–π—Ç–µ—Å—å, –∑–∞—Ç–µ–º –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ –æ–ø–ª–∞—Ç—É.",
+        )
+        return PANEL
+
+    settings = load_settings()
+    await send_paid_confirmation(context.bot, chat_id, settings=settings)
+    await _render_user_panel(
+        update=update,
+        context=context,
+        status_message="–°–ø–∞—Å–∏–±–æ! –ú—ã –æ—Ç–º–µ—Ç–∏–ª–∏ –æ–ø–ª–∞—Ç—É –∏ –æ—Ç–ø—Ä–∞–≤–∏–ª–∏ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ.",
+    )
+    return PANEL
+
+
+async def _handle_feedback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
+    query = update.callback_query
+    if query:
+        await query.answer()
+    context.user_data["awaiting_feedback"] = True
+    await _render_user_panel(
+        update=update,
+        context=context,
+        status_message="–ù–∞–ø–∏—à–∏—Ç–µ –≤–∞—à –æ—Ç–∑—ã–≤ –æ–¥–Ω–∏–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º.",
+    )
+    awaiting = context.application.bot_data.setdefault("awaiting_feedback", set())
+    awaiting.add(update.effective_chat.id)
+    return WAITING_FEEDBACK
+
+
+async def _handle_location(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
+    query = update.callback_query
+    if query:
+        await query.answer()
+    settings = load_settings()
+    location_link = settings.get("zoom_link") or settings.get("location_link")
+    if location_link:
+        await update.effective_chat.send_message(
+            f"–õ–æ–∫–∞—Ü–∏—è/—Å—Å—ã–ª–∫–∞: {location_link}", disable_web_page_preview=False
+        )
+    else:
+        await update.effective_chat.send_message("–õ–æ–∫–∞—Ü–∏—è –±—É–¥–µ—Ç –æ–±—ä—è–≤–ª–µ–Ω–∞ –ø–æ–∑–∂–µ.")
+    await _render_user_panel(update=update, context=context)
+    return PANEL
+
+
+def _build_ics_content(settings: dict) -> Optional[str]:
+    event_dt = _get_event_datetime(settings)
+    if not event_dt:
+        return None
+    ctx = get_event_context(settings)
+    dt_start = event_dt.astimezone(TZ)
+    dt_end = dt_start + timedelta(hours=1)
+    def _format(dt: datetime) -> str:
+        return dt.strftime("%Y%m%dT%H%M%S")
+
+    ics = [
+        "BEGIN:VCALENDAR",
+        "VERSION:2.0",
+        "PRODID:-//Psychology Webinar//EN",
+        "BEGIN:VEVENT",
+        f"UID:{dt_start.strftime('%Y%m%dT%H%M%S')}@psychology-webinar",
+        f"DTSTART;TZID={TIMEZONE}:{_format(dt_start)}",
+        f"DTEND;TZID={TIMEZONE}:{_format(dt_end)}",
+        f"SUMMARY:{ctx['title']}",
+        f"DESCRIPTION:{ctx['description']}",
+    ]
+    location = settings.get("zoom_link") or settings.get("location_link")
+    if location:
+        ics.append(f"LOCATION:{location}")
+    ics.extend(["END:VEVENT", "END:VCALENDAR"])
+    return "\n".join(ics)
+
+
+async def _handle_calendar(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
+    query = update.callback_query
+    if query:
+        await query.answer()
+    settings = load_settings()
+    content = _build_ics_content(settings)
+    if not content:
+        await update.effective_chat.send_message(
+            "–î–∞—Ç–∞ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è –ø–æ–∫–∞ –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∞, –∫–∞–ª–µ–Ω–¥–∞—Ä—å –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω."
+        )
+    else:
+        await update.effective_chat.send_document(
+            document=content.encode("utf-8"),
+            filename="event.ics",
+            caption="–î–æ–±–∞–≤—å—Ç–µ —Å–æ–±—ã—Ç–∏–µ –≤ –≤–∞—à –∫–∞–ª–µ–Ω–¥–∞—Ä—å",
+        )
+    await _render_user_panel(update=update, context=context)
+    return PANEL
+
+
+async def handle_user_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
+    data = update.callback_query.data if update.callback_query else ""
+    if data == USER_REGISTER:
+        return await _handle_registration(update, context)
+    if data == USER_REMIND_DAY:
+        return await _handle_reminder(update, context, REMINDER_DAY)
+    if data == USER_REMIND_HOUR:
+        return await _handle_reminder(update, context, REMINDER_HOUR)
+    if data == USER_UNSUBSCRIBE:
+        return await _handle_unsubscribe(update, context)
+    if data == USER_CONFIRMED_PAYMENT:
+        return await _handle_payment_confirmation(update, context)
+    if data == USER_FEEDBACK:
+        return await _handle_feedback(update, context)
+    if data == USER_LOCATION:
+        return await _handle_location(update, context)
+    if data == USER_CALENDAR:
+        return await _handle_calendar(update, context)
+    await update.callback_query.answer()
+    return PANEL
+
+
 async def handle_email(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
     email = (update.message.text or "").strip()
     if not EMAIL_REGEX.match(email):
-        await update.message.reply_text("–ü–æ—Ö–æ–∂–µ, —ç—Ç–æ –Ω–µ e-mail. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")
+        await update.message.reply_text("–ö–∞–∂–µ—Ç—Å—è, —ç—Ç–æ –Ω–µ –ø–æ—Ö–æ–∂–µ –Ω–∞ e-mail. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑.")
         return WAITING_EMAIL
 
+    chat_id = update.effective_chat.id
     user = update.effective_user
     participant = database.Participant(
         name=(user.full_name or "") if user else "",
         username=f"@{user.username}" if user and user.username else "",
-        chat_id=update.effective_chat.id,
+        chat_id=chat_id,
         email=email,
     )
     try:
         database.register_participant(participant)
     except RuntimeError:
         await update.message.reply_text(
-            "–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.",
-            reply_markup=ReplyKeyboardRemove(),
+            "–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
         )
-        return ConversationHandler.END
-
-    await update.message.reply_text(
-        "–í—ã –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã –Ω–∞ –≤–µ–±–∏–Ω–∞—Ä üí´ –°—Å—ã–ª–∫–∞ –ø—Ä–∏–¥—ë—Ç –≤ –¥–µ–Ω—å –ø—Ä–æ–≤–µ–¥–µ–Ω–∏—è.",
-    )
-
-    keyboard = ReplyKeyboardMarkup([[FREE_BUTTON], [PAID_BUTTON]], resize_keyboard=True)
-    await update.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ —Ñ–æ—Ä–º–∞—Ç —É—á–∞—Å—Ç–∏—è:", reply_markup=keyboard)
-    return WAITING_FORMAT
-
+        await _refresh_panel_from_state(
+            context=context,
+            chat_id=chat_id,
+            status_message="–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å—Å—è. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.",
+        )
+        return PANEL
 
-async def handle_format(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-    choice = (update.message.text or "").strip()
     settings = load_settings()
-    if choice == FREE_BUTTON:
-        database.update_participation(update.effective_chat.id, "free", "no")
-        confirmation = build_free_confirmation(settings)
-        await update.message.reply_text(confirmation, reply_markup=ReplyKeyboardRemove())
-        return ConversationHandler.END
+    confirmation = build_free_confirmation(settings)
+    await update.message.reply_text(confirmation)
+    await _refresh_panel_from_state(
+        context=context,
+        chat_id=chat_id,
+        status_message="–í—ã —É—Å–ø–µ—à–Ω–æ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã!",
+    )
+    context.user_data.pop("awaiting_email", None)
+    return PANEL
 
-    if choice == PAID_BUTTON:
-        database.update_participation(update.effective_chat.id, "paid", "no")
-        message = build_paid_pending_confirmation(settings)
-        await update.message.reply_text(message, reply_markup=ReplyKeyboardRemove())
-        return ConversationHandler.END
 
-    await update.message.reply_text(
-        "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –¥–ª—è –≤—ã–±–æ—Ä–∞ —Ñ–æ—Ä–º–∞—Ç–∞ —É—á–∞—Å—Ç–∏—è."
+async def handle_feedback_text(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
+    chat_id = update.effective_chat.id
+    feedback = (update.message.text or "").strip()
+    if not feedback:
+        await update.message.reply_text("–ù–∞–ø–∏—à–∏—Ç–µ, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, —Ç–µ–∫—Å—Ç –æ—Ç–∑—ã–≤–∞.")
+        return WAITING_FEEDBACK
+    database.update_feedback(chat_id, feedback)
+    awaiting = context.application.bot_data.setdefault("awaiting_feedback", set())
+    awaiting.discard(chat_id)
+    await update.message.reply_text("–°–ø–∞—Å–∏–±–æ –∑–∞ –æ–±—Ä–∞—Ç–Ω—É—é —Å–≤—è–∑—å! üíñ")
+    await _refresh_panel_from_state(
+        context=context,
+        chat_id=chat_id,
+        status_message="–û—Ç–∑—ã–≤ —Å–æ—Ö—Ä–∞–Ω—ë–Ω.",
     )
-    return WAITING_FORMAT
+    context.user_data.pop("awaiting_feedback", None)
+    return PANEL
 
 
 async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-    await update.message.reply_text(
-        "–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞.", reply_markup=ReplyKeyboardRemove()
-    )
-    return ConversationHandler.END
+    await update.message.reply_text("–î–µ–π—Å—Ç–≤–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ.")
+    context.user_data.pop("awaiting_email", None)
+    context.user_data.pop("awaiting_feedback", None)
+    await _refresh_panel_from_state(context=context, chat_id=update.effective_chat.id)
+    return PANEL
 
 
 async def feedback_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
     chat_id = update.effective_chat.id
     awaiting = context.application.bot_data.setdefault("awaiting_feedback", set())
     if chat_id not in awaiting:
         return
     feedback = (update.message.text or "").strip()
     if not feedback:
         return
     database.update_feedback(chat_id, feedback)
     awaiting.discard(chat_id)
     await update.message.reply_text("–°–ø–∞—Å–∏–±–æ –∑–∞ –æ–±—Ä–∞—Ç–Ω—É—é —Å–≤—è–∑—å! üíñ")
 
 
 def build_conversation_handler() -> ConversationHandler:
     return ConversationHandler(
         entry_points=[CommandHandler("start", start)],
         states={
+            PANEL: [CallbackQueryHandler(handle_user_callback, pattern=r"^user:")],
             WAITING_EMAIL: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_email)],
-            WAITING_FORMAT: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_format)],
+            WAITING_FEEDBACK: [
+                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_feedback_text)
+            ],
         },
         fallbacks=[CommandHandler("cancel", cancel)],
         allow_reentry=True,
     )
diff --git a/reminders.py b/reminders.py
new file mode 100644
index 0000000000000000000000000000000000000000..2d309eed4b576a4f366daa73f9511858bc6efddf
--- /dev/null
+++ b/reminders.py
@@ -0,0 +1,62 @@
+"""Personal reminder scheduling helpers for inline user actions."""
+from __future__ import annotations
+
+from datetime import datetime
+from typing import Optional
+
+from telegram.ext import ContextTypes
+
+from zoneinfo import ZoneInfo
+
+from config import TIMEZONE
+
+TZ = ZoneInfo(TIMEZONE)
+
+
+async def _deliver_personal_reminder(context: ContextTypes.DEFAULT_TYPE) -> None:
+    job = context.job
+    if job is None:
+        return
+    data = job.data or {}
+    chat_id = data.get("chat_id")
+    message = data.get("message")
+    if not chat_id or not message:
+        return
+    await context.bot.send_message(chat_id=chat_id, text=message)
+
+
+def schedule_personal_reminder(
+    context: ContextTypes.DEFAULT_TYPE,
+    *,
+    chat_id: int,
+    run_at: datetime,
+    message: str,
+    label: str,
+) -> Optional[datetime]:
+    """Schedule a per-user reminder, replacing previous jobs with the same label."""
+
+    if run_at.tzinfo is None:
+        run_at = run_at.replace(tzinfo=TZ)
+    if run_at <= datetime.now(run_at.tzinfo):
+        return None
+
+    job_queue = context.application.job_queue
+    job_name = f"user::{chat_id}::{label}"
+    for job in job_queue.get_jobs_by_name(job_name):
+        job.schedule_removal()
+
+    job_queue.run_once(
+        _deliver_personal_reminder,
+        when=run_at,
+        data={"chat_id": chat_id, "message": message},
+        name=job_name,
+        chat_id=chat_id,
+    )
+    return run_at
+
+
+def cancel_personal_reminder(context: ContextTypes.DEFAULT_TYPE, chat_id: int, label: str) -> None:
+    job_queue = context.application.job_queue
+    job_name = f"user::{chat_id}::{label}"
+    for job in job_queue.get_jobs_by_name(job_name):
+        job.schedule_removal()

