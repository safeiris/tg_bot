"""Inline administrative tools for configuring the webinar bot."""
from __future__ import annotations

import html
import re
from datetime import datetime
from typing import Dict, Optional
from uuid import uuid4

from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.constants import ParseMode
from telegram.ext import (
    CallbackQueryHandler,
    CommandHandler,
    ContextTypes,
    ConversationHandler,
    MessageHandler,
    filters,
)
from zoneinfo import ZoneInfo

import database
from config import TIMEZONE, is_admin, load_settings, update_settings
from scheduler import ensure_scheduler_started, schedule_all_reminders

ADMIN_PANEL, WAITING_BROADCAST, WAITING_WELCOME, NEW_EVENT_TITLE, NEW_EVENT_DESCRIPTION, NEW_EVENT_DATETIME, NEW_EVENT_ZOOM, NEW_EVENT_PAYMENT = range(8)

CALLBACK_NEW_EVENT = "admin:new_event"
CALLBACK_VIEW_REG = "admin:registrations"
CALLBACK_BROADCAST = "admin:broadcast"
CALLBACK_WELCOME = "admin:welcome"
CALLBACK_OPEN_SHEET = "admin:sheet"
CALLBACK_EXPORT_CSV = "admin:export"
CALLBACK_REFRESH = "admin:refresh"

TZ = ZoneInfo(TIMEZONE)


def _build_admin_keyboard() -> InlineKeyboardMarkup:
    keyboard = [
        [InlineKeyboardButton("üÜï –°–æ–∑–¥–∞—Ç—å –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ", callback_data=CALLBACK_NEW_EVENT)],
        [InlineKeyboardButton("üìã –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏", callback_data=CALLBACK_VIEW_REG)],
        [InlineKeyboardButton("üì¢ –ù–∞–ø–æ–º–Ω–∏—Ç—å –≤—Å–µ–º", callback_data=CALLBACK_BROADCAST)],
        [InlineKeyboardButton("üëã –ü—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ", callback_data=CALLBACK_WELCOME)],
        [InlineKeyboardButton("üìä Google Sheet", callback_data=CALLBACK_OPEN_SHEET)],
        [InlineKeyboardButton("‚¨áÔ∏è –≠–∫—Å–ø–æ—Ä—Ç CSV", callback_data=CALLBACK_EXPORT_CSV)],
        [InlineKeyboardButton("üîÑ –û–±–Ω–æ–≤–∏—Ç—å", callback_data=CALLBACK_REFRESH)],
    ]
    return InlineKeyboardMarkup(keyboard)


def _format_value(value: Optional[object]) -> str:
    if value is None:
        return "‚ùóÔ∏è–ù–µ —É–∫–∞–∑–∞–Ω–æ"
    if isinstance(value, str):
        stripped = value.strip()
        return stripped if stripped else "‚ùóÔ∏è–ù–µ —É–∫–∞–∑–∞–Ω–æ"
    return str(value)


def _event_datetime(settings: Dict[str, object]) -> Optional[datetime]:
    event_iso = settings.get("current_event_datetime")
    if not event_iso:
        return None
    try:
        return datetime.fromisoformat(str(event_iso))
    except ValueError:
        return None


def _format_datetime(dt: Optional[datetime]) -> str:
    if not dt:
        return "‚ùóÔ∏è–ù–µ —É–∫–∞–∑–∞–Ω–æ"
    local_dt = dt.astimezone(TZ)
    month_names = [
        "",
        "—è–Ω–≤–∞—Ä—è",
        "—Ñ–µ–≤—Ä–∞–ª—è",
        "–º–∞—Ä—Ç–∞",
        "–∞–ø—Ä–µ–ª—è",
        "–º–∞—è",
        "–∏—é–Ω—è",
        "–∏—é–ª—è",
        "–∞–≤–≥—É—Å—Ç–∞",
        "—Å–µ–Ω—Ç—è–±—Ä—è",
        "–æ–∫—Ç—è–±—Ä—è",
        "–Ω–æ—è–±—Ä—è",
        "–¥–µ–∫–∞–±—Ä—è",
    ]
    month = month_names[local_dt.month] if 1 <= local_dt.month <= 12 else local_dt.strftime("%B")
    return f"{local_dt.day} {month} {local_dt.year}, {local_dt.strftime('%H:%M')}"


def _build_panel_text(settings: Dict[str, object], extra: Optional[str] = None) -> str:
    topic = html.escape(_format_value(settings.get("topic")))
    description = html.escape(_format_value(settings.get("description")))
    welcome = html.escape(_format_value(settings.get("welcome_text")))
    zoom_link = html.escape(settings.get("zoom_link") or "‚ùóÔ∏è–ù–µ —É–∫–∞–∑–∞–Ω–æ")
    payment_link = html.escape(settings.get("payment_link") or "‚ùóÔ∏è–ù–µ —É–∫–∞–∑–∞–Ω–æ")
    dt_text = html.escape(_format_datetime(_event_datetime(settings)))

    lines = ["<b>–ü–∞–Ω–µ–ª—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞</b>"]
    lines.append(f"üëã –ü—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ: {welcome}")
    lines.append(f"üéì –ù–∞–∑–≤–∞–Ω–∏–µ: {topic}")
    lines.append(f"üìù –û–ø–∏—Å–∞–Ω–∏–µ: {description}")
    lines.append(f"üìÖ –î–∞—Ç–∞ –∏ –≤—Ä–µ–º—è: {dt_text}")
    lines.append(f"üîó Zoom: {zoom_link}")
    lines.append(f"üí≥ –û–ø–ª–∞—Ç–∞: {payment_link}")

    sheet_name = settings.get("current_event_sheet_name")
    if sheet_name:
        lines.append(f"üìä –ê–∫—Ç–∏–≤–Ω—ã–π –ª–∏—Å—Ç: {html.escape(sheet_name)}")
    else:
        lines.append("üìä –ê–∫—Ç–∏–≤–Ω—ã–π –ª–∏—Å—Ç: –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω")
    if extra:
        lines.append("")
        lines.append(extra)
    return "\n".join(lines)


async def _ensure_admin(update: Update) -> bool:
    user = update.effective_user
    if user and is_admin(chat_id=user.id, username=user.username):
        return True
    if update.message:
        await update.message.reply_text("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤ –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∫–æ–º–∞–Ω–¥—ã.")
    elif update.callback_query:
        await update.callback_query.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤", show_alert=True)
    return False


async def show_admin_panel(
    update: Update,
    context: ContextTypes.DEFAULT_TYPE,
    *,
    status_message: Optional[str] = None,
) -> None:
    settings = load_settings()
    text = _build_panel_text(settings, status_message)
    keyboard = _build_admin_keyboard()
    chat = update.effective_chat
    chat_id = chat.id if chat else None
    if update.callback_query and update.callback_query.message:
        await update.callback_query.message.edit_text(
            text,
            reply_markup=keyboard,
            parse_mode=ParseMode.HTML,
            disable_web_page_preview=True,
        )
        context.user_data["admin_panel_message_id"] = update.callback_query.message.message_id
        return

    message_id = context.user_data.get("admin_panel_message_id")
    if chat_id and message_id:
        try:
            await context.bot.edit_message_text(
                chat_id=chat_id,
                message_id=message_id,
                text=text,
                reply_markup=keyboard,
                parse_mode=ParseMode.HTML,
                disable_web_page_preview=True,
            )
            return
        except Exception:
            pass

    if chat_id:
        sent = await context.bot.send_message(
            chat_id=chat_id,
            text=text,
            reply_markup=keyboard,
            parse_mode=ParseMode.HTML,
            disable_web_page_preview=True,
        )
        context.user_data["admin_panel_message_id"] = sent.message_id


async def admin_command_entry(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    if not await _ensure_admin(update):
        return ConversationHandler.END
    await show_admin_panel(update, context)
    context.user_data.pop("new_event", None)
    return ADMIN_PANEL


def _slugify_topic(topic: str) -> str:
    normalized = re.sub(r"[^\w\s-]", "", topic, flags=re.UNICODE)
    normalized = normalized.strip().lower()
    normalized = re.sub(r"[\s./]+", "-", normalized)
    normalized = re.sub(r"-+", "-", normalized).strip("-")
    return normalized or "event"


def _generate_sheet_name(topic: str, event_dt: datetime) -> str:
    base_slug = _slugify_topic(topic)
    date_part = event_dt.astimezone(TZ).strftime("%d-%m-%Y")
    candidate = f"{date_part}__{base_slug}"
    suffix = 1
    while database.get_sheet_by_name(candidate) is not None:
        suffix += 1
        candidate = f"{date_part}__{base_slug}-{suffix}"
    return candidate[:30]


def _generate_event_id() -> str:
    return uuid4().hex[:12]


def _parse_datetime(text: str) -> datetime:
    variants = ["%d.%m.%Y %H:%M", "%d.%m %H:%M", "%Y-%m-%d %H:%M"]
    for fmt in variants:
        try:
            dt = datetime.strptime(text.strip(), fmt)
            if fmt == "%d.%m %H:%M":
                dt = dt.replace(year=datetime.now(TZ).year)
            return dt.replace(tzinfo=TZ)
        except ValueError:
            continue
    raise ValueError("invalid datetime")


async def _handle_view_reg(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    try:
        df = database.get_participants()
    except RuntimeError:
        await show_admin_panel(
            update,
            context,
            status_message="–ê–∫—Ç–∏–≤–Ω–æ–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–æ. –°–æ–∑–¥–∞–π—Ç–µ –Ω–æ–≤–æ–µ —Å–æ–±—ã—Ç–∏–µ.",
        )
        return ADMIN_PANEL
    total = len(df.index)
    preview = "\n".join(
        f"‚Ä¢ {row.get('–ò–º—è') or row.get('–ò–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è') or row.get('Email') or '‚Äî'}"
        for _, row in df.head(10).iterrows()
    )
    extra = f"–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–π: {total}"
    if preview:
        extra += f"\n–ü–µ—Ä–≤—ã–µ –∑–∞–ø–∏—Å–∏:\n{preview}"
    await show_admin_panel(update, context, status_message=extra)
    return ADMIN_PANEL


async def _handle_broadcast(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    if update.callback_query:
        await update.callback_query.answer()
    await show_admin_panel(
        update,
        context,
        status_message="–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è, –∫–æ—Ç–æ—Ä—ã–π –ø–æ–ª—É—á–∞—Ç –≤—Å–µ —É—á–∞—Å—Ç–Ω–∏–∫–∏.",
    )
    return WAITING_BROADCAST


async def _handle_welcome(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    if update.callback_query:
        await update.callback_query.answer()
    await show_admin_panel(
        update,
        context,
        status_message="–û—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–æ–≤—ã–π —Ç–µ–∫—Å—Ç –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏—è –¥–ª—è —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤.",
    )
    return WAITING_WELCOME


async def _handle_open_sheet(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    try:
        link = database.get_sheet_link()
    except RuntimeError:
        await show_admin_panel(
            update,
            context,
            status_message="–ê–∫—Ç–∏–≤–Ω—ã–π –ª–∏—Å—Ç –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω. –°–æ–∑–¥–∞–π—Ç–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ.",
        )
        return ADMIN_PANEL
    await update.effective_chat.send_message(link, disable_web_page_preview=False)
    await show_admin_panel(
        update,
        context,
        status_message="–°—Å—ã–ª–∫–∞ –Ω–∞ Google Sheet –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –≤ —á–∞—Ç.",
    )
    return ADMIN_PANEL


async def _handle_export(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    try:
        path = database.export_database_csv()
    except RuntimeError:
        await show_admin_panel(
            update,
            context,
            status_message="–ù–µ —É–¥–∞–ª–æ—Å—å —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å: –∞–∫—Ç–∏–≤–Ω–æ–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–æ.",
        )
        return ADMIN_PANEL
    await update.effective_chat.send_document(document=path.read_bytes(), filename=path.name)
    await show_admin_panel(
        update,
        context,
        status_message="CSV-—Ñ–∞–π–ª —Å–æ —Å–ø–∏—Å–∫–æ–º —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω.",
    )
    return ADMIN_PANEL


async def _handle_new_event(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    if update.callback_query:
        await update.callback_query.answer()
    context.user_data["new_event"] = {}
    await show_admin_panel(
        update,
        context,
        status_message="–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è.",
    )
    return NEW_EVENT_TITLE


async def handle_admin_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    if not query:
        return ADMIN_PANEL
    if not await _ensure_admin(update):
        await query.answer()
        return ConversationHandler.END
    data = query.data
    if data == CALLBACK_NEW_EVENT:
        return await _handle_new_event(update, context)
    if data == CALLBACK_VIEW_REG:
        return await _handle_view_reg(update, context)
    if data == CALLBACK_BROADCAST:
        return await _handle_broadcast(update, context)
    if data == CALLBACK_WELCOME:
        return await _handle_welcome(update, context)
    if data == CALLBACK_OPEN_SHEET:
        return await _handle_open_sheet(update, context)
    if data == CALLBACK_EXPORT_CSV:
        return await _handle_export(update, context)
    if data == CALLBACK_REFRESH:
        await show_admin_panel(update, context)
        return ADMIN_PANEL
    await query.answer()
    return ADMIN_PANEL


async def handle_broadcast_text(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    if not await _ensure_admin(update):
        return ConversationHandler.END
    text = (update.message.text or "").strip()
    if not text:
        await update.message.reply_text("–°–æ–æ–±—â–µ–Ω–∏–µ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")
        return WAITING_BROADCAST
    participants = database.list_chat_ids()
    for chat_id in participants:
        await context.bot.send_message(chat_id=chat_id, text=text)
    await show_admin_panel(update, context, status_message="–†–∞—Å—Å—ã–ª–∫–∞ —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞.")
    return ADMIN_PANEL


async def handle_welcome_text(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    if not await _ensure_admin(update):
        return ConversationHandler.END
    text = (update.message.text or "").strip()
    if not text:
        await update.message.reply_text("–ü—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.")
        return WAITING_WELCOME
    settings = update_settings(welcome_text=text)
    await show_admin_panel(update, context, status_message="–ü—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ –æ–±–Ω–æ–≤–ª–µ–Ω–æ.")
    return ADMIN_PANEL


async def new_event_title(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    if not await _ensure_admin(update):
        return ConversationHandler.END
    text = (update.message.text or "").strip()
    if not text:
        await update.message.reply_text("–ù–∞–∑–≤–∞–Ω–∏–µ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")
        return NEW_EVENT_TITLE
    context.user_data.setdefault("new_event", {})["topic"] = text
    await show_admin_panel(update, context, status_message="–í–≤–µ–¥–∏—Ç–µ –æ–ø–∏—Å–∞–Ω–∏–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è (–º–æ–∂–Ω–æ –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å –ø—É—Å—Ç—ã–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º).")
    return NEW_EVENT_DESCRIPTION


async def new_event_description(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    if not await _ensure_admin(update):
        return ConversationHandler.END
    text = (update.message.text or "").strip()
    context.user_data.setdefault("new_event", {})["description"] = text
    await show_admin_panel(
        update,
        context,
        status_message="–í–≤–µ–¥–∏—Ç–µ –¥–∞—Ç—É –∏ –≤—Ä–µ–º—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ –î–î.–ú–ú.–ì–ì–ì–ì –ß–ß:–ú–ú –∏–ª–∏ –î–î.–ú–ú –ß–ß:–ú–ú.",
    )
    return NEW_EVENT_DATETIME


async def new_event_datetime(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    if not await _ensure_admin(update):
        return ConversationHandler.END
    text = (update.message.text or "").strip()
    try:
        dt = _parse_datetime(text)
    except ValueError:
        await update.message.reply_text("–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å –¥–∞—Ç—É. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")
        return NEW_EVENT_DATETIME
    context.user_data.setdefault("new_event", {})["datetime"] = dt
    await show_admin_panel(update, context, status_message="–£–∫–∞–∂–∏—Ç–µ —Å—Å—ã–ª–∫—É –Ω–∞ Zoom (–∏–ª–∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –ø—É—Å—Ç–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ).")
    return NEW_EVENT_ZOOM


async def new_event_zoom(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    if not await _ensure_admin(update):
        return ConversationHandler.END
    text = (update.message.text or "").strip()
    context.user_data.setdefault("new_event", {})["zoom_link"] = text
    await show_admin_panel(update, context, status_message="–£–∫–∞–∂–∏—Ç–µ —Å—Å—ã–ª–∫—É –Ω–∞ –æ–ø–ª–∞—Ç—É (–∏–ª–∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –ø—É—Å—Ç–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ).")
    return NEW_EVENT_PAYMENT


async def _finalize_new_event(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    data = context.user_data.get("new_event") or {}
    topic = data.get("topic")
    event_dt: Optional[datetime] = data.get("datetime")
    if not topic or not event_dt:
        await show_admin_panel(
            update,
            context,
            status_message="–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è.",
        )
        context.user_data.pop("new_event", None)
        return ADMIN_PANEL
    description = data.get("description", "")
    zoom_link = data.get("zoom_link", "")
    payment_link = data.get("payment_link", "")

    sheet_name = _generate_sheet_name(topic, event_dt)
    worksheet = database.get_or_create_sheet(sheet_name)
    event_id = _generate_event_id()

    update_settings(
        topic=topic,
        description=description,
        zoom_link=zoom_link,
        payment_link=payment_link,
        current_event_id=event_id,
        current_event_sheet_name=worksheet.title,
        current_event_sheet_gid=worksheet.id,
        current_event_datetime=event_dt.isoformat(),
        timezone=TIMEZONE,
    )

    context.user_data.pop("new_event", None)
    ensure_scheduler_started()
    schedule_all_reminders(context.application)

    link = database.get_sheet_link(worksheet.title, worksheet.id)
    await show_admin_panel(
        update,
        context,
        status_message=f"–ù–æ–≤–æ–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ —Å–æ–∑–¥–∞–Ω–æ. –°—Å—ã–ª–∫–∞ –Ω–∞ –ª–∏—Å—Ç: {link}",
    )
    return ADMIN_PANEL


async def new_event_payment(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    if not await _ensure_admin(update):
        return ConversationHandler.END
    text = (update.message.text or "").strip()
    context.user_data.setdefault("new_event", {})["payment_link"] = text
    return await _finalize_new_event(update, context)


async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    if not await _ensure_admin(update):
        return ConversationHandler.END
    await update.message.reply_text("–î–µ–π—Å—Ç–≤–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ.")
    context.user_data.pop("new_event", None)
    await show_admin_panel(update, context)
    return ADMIN_PANEL


def build_admin_conversation() -> ConversationHandler:
    return ConversationHandler(
        entry_points=[CommandHandler("admin", admin_command_entry)],
        states={
            ADMIN_PANEL: [CallbackQueryHandler(handle_admin_callback, pattern=r"^admin:")],
            WAITING_BROADCAST: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_broadcast_text)],
            WAITING_WELCOME: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_welcome_text)],
            NEW_EVENT_TITLE: [MessageHandler(filters.TEXT & ~filters.COMMAND, new_event_title)],
            NEW_EVENT_DESCRIPTION: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, new_event_description)
            ],
            NEW_EVENT_DATETIME: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, new_event_datetime)
            ],
            NEW_EVENT_ZOOM: [MessageHandler(filters.TEXT & ~filters.COMMAND, new_event_zoom)],
            NEW_EVENT_PAYMENT: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, new_event_payment)
            ],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
        allow_reentry=True,
    )
